{"ast":null,"code":"'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar utils = require('./lib/utils');\nvar Command = require('./lib/command');\nvar Queue = require('denque');\nvar errorClasses = require('./lib/customErrors');\nvar EventEmitter = require('events');\nvar Parser = require('redis-parser');\nvar RedisErrors = require('redis-errors');\nvar commands = require('redis-commands');\nvar debug = require('./lib/debug');\nvar unifyOptions = require('./lib/createClient');\nvar SUBSCRIBE_COMMANDS = {\n  subscribe: true,\n  unsubscribe: true,\n  psubscribe: true,\n  punsubscribe: true\n};\nfunction noop() {}\nfunction handle_detect_buffers_reply(reply, command, buffer_args) {\n  if (buffer_args === false || this.message_buffers) {\n    // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n    // If this command did not use Buffer arguments, then convert the reply to Strings here.\n    reply = utils.reply_to_strings(reply);\n  }\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n  return reply;\n}\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG);\n\n// Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\nfunction RedisClient(options, stream) {\n  // Copy the options so they are not mutated\n  options = utils.clone(options);\n  EventEmitter.call(this);\n  var cnx_options = {};\n  var self = this;\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n  for (var tls_option in options.tls) {\n    cnx_options[tls_option] = options.tls[tls_option];\n    // Copy the tls options into the general options to make sure the address is set right\n    if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n      options[tls_option] = options.tls[tls_option];\n    }\n  }\n  if (stream) {\n    // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n    // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n    options.stream = stream;\n    this.address = '\"Private stream\"';\n  } else if (options.path) {\n    cnx_options.path = options.path;\n    this.address = options.path;\n  } else {\n    cnx_options.port = +options.port || 6379;\n    cnx_options.host = options.host || '127.0.0.1';\n    cnx_options.family = !options.family && net.isIP(cnx_options.host) || (options.family === 'IPv6' ? 6 : 4);\n    this.address = cnx_options.host + ':' + cnx_options.port;\n  }\n  this.connection_options = cnx_options;\n  this.connection_id = RedisClient.connection_id++;\n  this.connected = false;\n  this.ready = false;\n  if (options.socket_keepalive === undefined) {\n    options.socket_keepalive = true;\n  }\n  if (options.socket_initial_delay === undefined) {\n    options.socket_initial_delay = 0;\n    // set default to 0, which is aligned to https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay\n  }\n\n  for (var command in options.rename_commands) {\n    options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n  }\n  options.return_buffers = !!options.return_buffers;\n  options.detect_buffers = !!options.detect_buffers;\n  // Override the detect_buffers setting if return_buffers is active and print a warning\n  if (options.return_buffers && options.detect_buffers) {\n    self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n    options.detect_buffers = false;\n  }\n  if (options.detect_buffers) {\n    // We only need to look at the arguments if we do not know what we have to return\n    this.handle_reply = handle_detect_buffers_reply;\n  }\n  this.should_buffer = false;\n  this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n  this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n  this.pipeline_queue = new Queue(); // Holds all pipelined commands\n  // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n  // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n  this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n  this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n  this.initialize_retry_vars();\n  this.pub_sub_mode = 0;\n  this.subscription_set = {};\n  this.monitoring = false;\n  this.message_buffers = false;\n  this.closing = false;\n  this.server_info = {};\n  this.auth_pass = options.auth_pass || options.password;\n  this.selected_db = options.db; // Save the selected db here, used when reconnecting\n  this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n  this.pipeline = false;\n  this.sub_commands_left = 0;\n  this.times_connected = 0;\n  this.buffers = options.return_buffers || options.detect_buffers;\n  this.options = options;\n  this.reply = 'ON'; // Returning replies is the default\n  this.create_stream();\n  // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n  this.on('newListener', function (event) {\n    if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n      this.reply_parser.optionReturnBuffers = true;\n      this.message_buffers = true;\n      this.handle_reply = handle_detect_buffers_reply;\n    }\n  });\n}\nutil.inherits(RedisClient, EventEmitter);\nRedisClient.connection_id = 0;\nfunction create_parser(self) {\n  return new Parser({\n    returnReply: function (data) {\n      self.return_reply(data);\n    },\n    returnError: function (err) {\n      // Return a ReplyError to indicate Redis returned an error\n      self.return_error(err);\n    },\n    returnFatalError: function (err) {\n      // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n      // Note: the execution order is important. First flush and emit, then create the stream\n      err.message += '. Please report this.';\n      self.ready = false;\n      self.flush_and_error({\n        message: 'Fatal error encountered. Command aborted.',\n        code: 'NR_FATAL'\n      }, {\n        error: err,\n        queues: ['command_queue']\n      });\n      self.emit('error', err);\n      self.create_stream();\n    },\n    returnBuffers: self.buffers || self.message_buffers,\n    stringNumbers: self.options.string_numbers || false\n  });\n}\n\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\nRedisClient.prototype.create_stream = function () {\n  var self = this;\n\n  // Init parser\n  this.reply_parser = create_parser(this);\n  if (this.options.stream) {\n    // Only add the listeners once in case of a reconnect try (that won't work)\n    if (this.stream) {\n      return;\n    }\n    this.stream = this.options.stream;\n  } else {\n    // On a reconnect destroy the former stream and retry\n    if (this.stream) {\n      this.stream.removeAllListeners();\n      this.stream.destroy();\n    }\n\n    /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    if (this.options.tls) {\n      this.stream = tls.connect(this.connection_options);\n    } else {\n      this.stream = net.createConnection(this.connection_options);\n    }\n  }\n  if (this.options.connect_timeout) {\n    this.stream.setTimeout(this.connect_timeout, function () {\n      // Note: This is only tested if a internet connection is established\n      self.retry_totaltime = self.connect_timeout;\n      self.connection_gone('timeout');\n    });\n  }\n\n  /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n  var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n  this.stream.once(connect_event, function () {\n    this.removeAllListeners('timeout');\n    self.times_connected++;\n    self.on_connect();\n  });\n  this.stream.on('data', function (buffer_from_socket) {\n    // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n    debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n    self.reply_parser.execute(buffer_from_socket);\n  });\n  this.stream.on('error', function (err) {\n    self.on_error(err);\n  });\n  this.stream.once('close', function (hadError) {\n    self.connection_gone('close');\n  });\n  this.stream.once('end', function () {\n    self.connection_gone('end');\n  });\n  this.stream.on('drain', function () {\n    self.drain();\n  });\n  this.stream.setNoDelay();\n\n  // Fire the command before redis is connected to be sure it's the first fired command\n  if (this.auth_pass !== undefined) {\n    this.ready = true;\n    // Fail silently as we might not be able to connect\n    this.auth(this.auth_pass, function (err) {\n      if (err && err.code !== 'UNCERTAIN_STATE') {\n        self.emit('error', err);\n      }\n    });\n    this.ready = false;\n  }\n};\nRedisClient.prototype.handle_reply = function (reply, command) {\n  if (command === 'hgetall') {\n    reply = utils.reply_to_object(reply);\n  }\n  return reply;\n};\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\nRedisClient.prototype.initialize_retry_vars = function () {\n  this.retry_timer = null;\n  this.retry_totaltime = 0;\n  this.retry_delay = 200;\n  this.retry_backoff = 1.7;\n  this.attempts = 1;\n};\nRedisClient.prototype.warn = function (msg) {\n  var self = this;\n  // Warn on the next tick. Otherwise no event listener can be added\n  // for warnings that are emitted in the redis client constructor\n  process.nextTick(function () {\n    if (self.listeners('warning').length !== 0) {\n      self.emit('warning', msg);\n    } else {\n      console.warn('node_redis:', msg);\n    }\n  });\n};\n\n// Flush provided queues, erroring any items with a callback first\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n  options = options || {};\n  var aggregated_errors = [];\n  var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n  for (var i = 0; i < queue_names.length; i++) {\n    // If the command was fired it might have been processed so far\n    if (queue_names[i] === 'command_queue') {\n      error_attributes.message += ' It might have been processed.';\n    } else {\n      // As the command_queue is flushed first, remove this for the offline queue\n      error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n    }\n    // Don't flush everything from the queue\n    for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n      var err = new errorClasses.AbortError(error_attributes);\n      if (command_obj.error) {\n        err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n      }\n      err.command = command_obj.command.toUpperCase();\n      if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n      }\n      if (options.error) {\n        err.origin = options.error;\n      }\n      if (typeof command_obj.callback === 'function') {\n        command_obj.callback(err);\n      } else {\n        aggregated_errors.push(err);\n      }\n    }\n  }\n  // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n  if (exports.debug_mode && aggregated_errors.length) {\n    var error;\n    if (aggregated_errors.length === 1) {\n      error = aggregated_errors[0];\n    } else {\n      error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n      error = new errorClasses.AggregateError(error_attributes);\n      error.errors = aggregated_errors;\n    }\n    this.emit('error', error);\n  }\n};\nRedisClient.prototype.on_error = function (err) {\n  if (this.closing) {\n    return;\n  }\n  err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n  debug(err.message);\n  this.connected = false;\n  this.ready = false;\n\n  // Only emit the error if the retry_strategy option is not set\n  if (!this.options.retry_strategy) {\n    this.emit('error', err);\n  }\n  // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n  // then we should try to reconnect.\n  this.connection_gone('error', err);\n};\nRedisClient.prototype.on_connect = function () {\n  debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n  this.connected = true;\n  this.ready = false;\n  this.emitted_end = false;\n  this.stream.setKeepAlive(this.options.socket_keepalive, this.options.socket_initial_delay);\n  this.stream.setTimeout(0);\n  this.emit('connect');\n  this.initialize_retry_vars();\n  if (this.options.no_ready_check) {\n    this.on_ready();\n  } else {\n    this.ready_check();\n  }\n};\nRedisClient.prototype.on_ready = function () {\n  var self = this;\n  debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n  this.ready = true;\n  this.cork = function () {\n    self.pipeline = true;\n    if (self.stream.cork) {\n      self.stream.cork();\n    }\n  };\n  this.uncork = function () {\n    if (self.fire_strings) {\n      self.write_strings();\n    } else {\n      self.write_buffers();\n    }\n    self.pipeline = false;\n    self.fire_strings = true;\n    if (self.stream.uncork) {\n      // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n      self.stream.uncork();\n    }\n  };\n\n  // Restore modal commands from previous connection. The order of the commands is important\n  if (this.selected_db !== undefined) {\n    this.internal_send_command(new Command('select', [this.selected_db]));\n  }\n  if (this.monitoring) {\n    // Monitor has to be fired before pub sub commands\n    this.internal_send_command(new Command('monitor', []));\n  }\n  var callback_count = Object.keys(this.subscription_set).length;\n  if (!this.options.disable_resubscribing && callback_count) {\n    // only emit 'ready' when all subscriptions were made again\n    // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n    // We know we are ready as soon as all commands were fired\n    var callback = function () {\n      callback_count--;\n      if (callback_count === 0) {\n        self.emit('ready');\n      }\n    };\n    debug('Sending pub/sub on_ready commands');\n    for (var key in this.subscription_set) {\n      var command = key.slice(0, key.indexOf('_'));\n      var args = this.subscription_set[key];\n      this[command]([args], callback);\n    }\n    this.send_offline_queue();\n    return;\n  }\n  this.send_offline_queue();\n  this.emit('ready');\n};\nRedisClient.prototype.on_info_cmd = function (err, res) {\n  if (err) {\n    if (err.message === \"ERR unknown command 'info'\") {\n      this.on_ready();\n      return;\n    }\n    err.message = 'Ready check failed: ' + err.message;\n    this.emit('error', err);\n    return;\n  }\n\n  /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n  if (!res) {\n    debug('The info command returned without any data.');\n    this.on_ready();\n    return;\n  }\n  if (!this.server_info.loading || this.server_info.loading === '0') {\n    // If the master_link_status exists but the link is not up, try again after 50 ms\n    if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n      this.server_info.loading_eta_seconds = 0.05;\n    } else {\n      // Eta loading should change\n      debug('Redis server ready.');\n      this.on_ready();\n      return;\n    }\n  }\n  var retry_time = +this.server_info.loading_eta_seconds * 1000;\n  if (retry_time > 1000) {\n    retry_time = 1000;\n  }\n  debug('Redis server still loading, trying again in ' + retry_time);\n  setTimeout(function (self) {\n    self.ready_check();\n  }, retry_time, this);\n};\nRedisClient.prototype.ready_check = function () {\n  var self = this;\n  debug('Checking server ready state...');\n  // Always fire this info command as first command even if other commands are already queued up\n  this.ready = true;\n  this.info(function (err, res) {\n    self.on_info_cmd(err, res);\n  });\n  this.ready = false;\n};\nRedisClient.prototype.send_offline_queue = function () {\n  for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n    debug('Sending offline command: ' + command_obj.command);\n    this.internal_send_command(command_obj);\n  }\n  this.drain();\n};\nvar retry_connection = function (self, error) {\n  debug('Retrying connection...');\n  var reconnect_params = {\n    delay: self.retry_delay,\n    attempt: self.attempts,\n    error: error\n  };\n  if (self.options.camel_case) {\n    reconnect_params.totalRetryTime = self.retry_totaltime;\n    reconnect_params.timesConnected = self.times_connected;\n  } else {\n    reconnect_params.total_retry_time = self.retry_totaltime;\n    reconnect_params.times_connected = self.times_connected;\n  }\n  self.emit('reconnecting', reconnect_params);\n  self.retry_totaltime += self.retry_delay;\n  self.attempts += 1;\n  self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n  self.create_stream();\n  self.retry_timer = null;\n};\nRedisClient.prototype.connection_gone = function (why, error) {\n  // If a retry is already in progress, just let that happen\n  if (this.retry_timer) {\n    return;\n  }\n  error = error || null;\n  debug('Redis connection is gone from ' + why + ' event.');\n  this.connected = false;\n  this.ready = false;\n  // Deactivate cork to work with the offline queue\n  this.cork = noop;\n  this.uncork = noop;\n  this.pipeline = false;\n  this.pub_sub_mode = 0;\n\n  // since we are collapsing end and close, users don't expect to be called twice\n  if (!this.emitted_end) {\n    this.emit('end');\n    this.emitted_end = true;\n  }\n\n  // If this is a requested shutdown, then don't retry\n  if (this.closing) {\n    debug('Connection ended by quit / end command, not retrying.');\n    this.flush_and_error({\n      message: 'Stream connection ended and command aborted.',\n      code: 'NR_CLOSED'\n    }, {\n      error: error\n    });\n    return;\n  }\n  if (typeof this.options.retry_strategy === 'function') {\n    var retry_params = {\n      attempt: this.attempts,\n      error: error\n    };\n    if (this.options.camel_case) {\n      retry_params.totalRetryTime = this.retry_totaltime;\n      retry_params.timesConnected = this.times_connected;\n    } else {\n      retry_params.total_retry_time = this.retry_totaltime;\n      retry_params.times_connected = this.times_connected;\n    }\n    this.retry_delay = this.options.retry_strategy(retry_params);\n    if (typeof this.retry_delay !== 'number') {\n      // Pass individual error through\n      if (this.retry_delay instanceof Error) {\n        error = this.retry_delay;\n      }\n      var errorMessage = 'Redis connection in broken state: ';\n      if (this.retry_totaltime >= this.connect_timeout) {\n        errorMessage += 'connection timeout exceeded.';\n      } else {\n        errorMessage += 'maximum connection attempts exceeded.';\n      }\n      this.flush_and_error({\n        message: errorMessage,\n        code: 'CONNECTION_BROKEN'\n      }, {\n        error: error\n      });\n      var retryError = new Error(errorMessage);\n      retryError.code = 'CONNECTION_BROKEN';\n      if (error) {\n        retryError.origin = error;\n      }\n      this.end(false);\n      this.emit('error', retryError);\n      return;\n    }\n  }\n  if (this.retry_totaltime >= this.connect_timeout) {\n    var message = 'Redis connection in broken state: ';\n    if (this.retry_totaltime >= this.connect_timeout) {\n      message += 'connection timeout exceeded.';\n    } else {\n      message += 'maximum connection attempts exceeded.';\n    }\n    this.flush_and_error({\n      message: message,\n      code: 'CONNECTION_BROKEN'\n    }, {\n      error: error\n    });\n    var err = new Error(message);\n    err.code = 'CONNECTION_BROKEN';\n    if (error) {\n      err.origin = error;\n    }\n    this.end(false);\n    this.emit('error', err);\n    return;\n  }\n\n  // Retry commands after a reconnect instead of throwing an error. Use this with caution\n  if (this.options.retry_unfulfilled_commands) {\n    this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n    this.command_queue.clear();\n  } else if (this.command_queue.length !== 0) {\n    this.flush_and_error({\n      message: 'Redis connection lost and command aborted.',\n      code: 'UNCERTAIN_STATE'\n    }, {\n      error: error,\n      queues: ['command_queue']\n    });\n  }\n  if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n    // Do not exceed the maximum\n    this.retry_delay = this.connect_timeout - this.retry_totaltime;\n  }\n  debug('Retry connection in ' + this.retry_delay + ' ms');\n  this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\nRedisClient.prototype.return_error = function (err) {\n  var command_obj = this.command_queue.shift();\n  if (command_obj.error) {\n    err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n  }\n  err.command = command_obj.command.toUpperCase();\n  if (command_obj.args && command_obj.args.length) {\n    err.args = command_obj.args;\n  }\n\n  // Count down pub sub mode if in entering modus\n  if (this.pub_sub_mode > 1) {\n    this.pub_sub_mode--;\n  }\n  var match = err.message.match(utils.err_code);\n  // LUA script could return user errors that don't behave like all other errors!\n  if (match) {\n    err.code = match[1];\n  }\n  utils.callback_or_emit(this, command_obj.callback, err);\n};\nRedisClient.prototype.drain = function () {\n  this.should_buffer = false;\n};\nfunction normal_reply(self, reply) {\n  var command_obj = self.command_queue.shift();\n  if (typeof command_obj.callback === 'function') {\n    if (command_obj.command !== 'exec') {\n      reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n    }\n    command_obj.callback(null, reply);\n  } else {\n    debug('No callback for reply');\n  }\n}\nfunction subscribe_unsubscribe(self, reply, type) {\n  // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n  // The pub sub commands return each argument in a separate return value and have to be handled that way\n  var command_obj = self.command_queue.get(0);\n  var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n  var channel = buffer || reply[1] === null ? reply[1] : reply[1].toString();\n  var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n  debug(type, channel);\n\n  // Emit first, then return the callback\n  if (channel !== null) {\n    // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n    self.emit(type, channel, count);\n    if (type === 'subscribe' || type === 'psubscribe') {\n      self.subscription_set[type + '_' + channel] = channel;\n    } else {\n      type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n      delete self.subscription_set[type + '_' + channel];\n    }\n  }\n  if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n    if (count === 0) {\n      // unsubscribed from all channels\n      var running_command;\n      var i = 1;\n      self.pub_sub_mode = 0; // Deactivating pub sub mode\n      // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n      while (running_command = self.command_queue.get(i)) {\n        if (SUBSCRIBE_COMMANDS[running_command.command]) {\n          self.pub_sub_mode = i; // Entering pub sub mode again\n          break;\n        }\n        i++;\n      }\n    }\n    self.command_queue.shift();\n    if (typeof command_obj.callback === 'function') {\n      // TODO: The current return value is pretty useless.\n      // Evaluate to change this in v.4 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n      command_obj.callback(null, channel);\n    }\n    self.sub_commands_left = 0;\n  } else {\n    if (self.sub_commands_left !== 0) {\n      self.sub_commands_left--;\n    } else {\n      self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n    }\n  }\n}\nfunction return_pub_sub(self, reply) {\n  var type = reply[0].toString();\n  if (type === 'message') {\n    // channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n      self.emit('message', reply[1].toString(), reply[2].toString());\n      self.emit('message_buffer', reply[1], reply[2]);\n      self.emit('messageBuffer', reply[1], reply[2]);\n    } else {\n      self.emit('message', reply[1], reply[2]);\n    }\n  } else if (type === 'pmessage') {\n    // pattern, channel, message\n    if (!self.options.return_buffers || self.message_buffers) {\n      // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n      self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n      self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n      self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n    } else {\n      self.emit('pmessage', reply[1], reply[2], reply[3]);\n    }\n  } else {\n    subscribe_unsubscribe(self, reply, type);\n  }\n}\nRedisClient.prototype.return_reply = function (reply) {\n  if (this.monitoring) {\n    var replyStr;\n    if (this.buffers && Buffer.isBuffer(reply)) {\n      replyStr = reply.toString();\n    } else {\n      replyStr = reply;\n    }\n    // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n    if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n      var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n      var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n        return elem.replace(/\\\\\"/g, '\"');\n      });\n      this.emit('monitor', timestamp, args, replyStr);\n      return;\n    }\n  }\n  if (this.pub_sub_mode === 0) {\n    normal_reply(this, reply);\n  } else if (this.pub_sub_mode !== 1) {\n    this.pub_sub_mode--;\n    normal_reply(this, reply);\n  } else if (!(reply instanceof Array) || reply.length <= 2) {\n    // Only PING and QUIT are allowed in this context besides the pub sub commands\n    // Ping replies with ['pong', null|value] and quit with 'OK'\n    normal_reply(this, reply);\n  } else {\n    return_pub_sub(this, reply);\n  }\n};\nfunction handle_offline_command(self, command_obj) {\n  var command = command_obj.command;\n  var err, msg;\n  if (self.closing || !self.enable_offline_queue) {\n    command = command.toUpperCase();\n    if (!self.closing) {\n      if (self.stream.writable) {\n        msg = 'The connection is not yet established and the offline queue is deactivated.';\n      } else {\n        msg = 'Stream not writeable.';\n      }\n    } else {\n      msg = 'The connection is already closed.';\n    }\n    err = new errorClasses.AbortError({\n      message: command + \" can't be processed. \" + msg,\n      code: 'NR_CLOSED',\n      command: command\n    });\n    if (command_obj.args.length) {\n      err.args = command_obj.args;\n    }\n    utils.reply_in_order(self, command_obj.callback, err);\n  } else {\n    debug('Queueing ' + command + ' for next server connection.');\n    self.offline_queue.push(command_obj);\n  }\n  self.should_buffer = true;\n}\n\n// Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\nRedisClient.prototype.internal_send_command = function (command_obj) {\n  var arg, prefix_keys;\n  var i = 0;\n  var command_str = '';\n  var args = command_obj.args;\n  var command = command_obj.command;\n  var len = args.length;\n  var big_data = false;\n  var args_copy = new Array(len);\n  if (process.domain && command_obj.callback) {\n    command_obj.callback = process.domain.bind(command_obj.callback);\n  }\n  if (this.ready === false || this.stream.writable === false) {\n    // Handle offline commands right away\n    handle_offline_command(this, command_obj);\n    return false; // Indicate buffering\n  }\n\n  for (i = 0; i < len; i += 1) {\n    if (typeof args[i] === 'string') {\n      // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n      if (args[i].length > 30000) {\n        big_data = true;\n        args_copy[i] = Buffer.from(args[i], 'utf8');\n      } else {\n        args_copy[i] = args[i];\n      }\n    } else if (typeof args[i] === 'object') {\n      // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n      if (args[i] instanceof Date) {\n        // Accept dates as valid input\n        args_copy[i] = args[i].toString();\n      } else if (Buffer.isBuffer(args[i])) {\n        args_copy[i] = args[i];\n        command_obj.buffer_args = true;\n        big_data = true;\n      } else {\n        var invalidArgError = new Error('node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type.\\n' + 'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.');\n        invalidArgError.command = command_obj.command.toUpperCase();\n        if (command_obj.args && command_obj.args.length) {\n          invalidArgError.args = command_obj.args;\n        }\n        if (command_obj.callback) {\n          command_obj.callback(invalidArgError);\n          return false;\n        }\n        throw invalidArgError;\n      }\n    } else if (typeof args[i] === 'undefined') {\n      var undefinedArgError = new Error('node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type of \"undefined\".\\n' + 'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.');\n      undefinedArgError.command = command_obj.command.toUpperCase();\n      if (command_obj.args && command_obj.args.length) {\n        undefinedArgError.args = command_obj.args;\n      }\n      if (command_obj.callback) {\n        command_obj.callback(undefinedArgError);\n        return false;\n      }\n      throw undefinedArgError;\n    } else {\n      // Seems like numbers are converted fast using string concatenation\n      args_copy[i] = '' + args[i];\n    }\n  }\n  if (this.options.prefix) {\n    prefix_keys = commands.getKeyIndexes(command, args_copy);\n    for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n      args_copy[i] = this.options.prefix + args_copy[i];\n    }\n  }\n  if (this.options.rename_commands && this.options.rename_commands[command]) {\n    command = this.options.rename_commands[command];\n  }\n  // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n  // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n  command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n  if (big_data === false) {\n    // Build up a string and send entire command in one write\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n      command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n    }\n    debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n    this.write(command_str);\n  } else {\n    debug('Send command (' + command_str + ') has Buffer arguments');\n    this.fire_strings = false;\n    this.write(command_str);\n    for (i = 0; i < len; i += 1) {\n      arg = args_copy[i];\n      if (typeof arg === 'string') {\n        this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n      } else {\n        // buffer\n        this.write('$' + arg.length + '\\r\\n');\n        this.write(arg);\n        this.write('\\r\\n');\n      }\n      debug('send_command: buffer send ' + arg.length + ' bytes');\n    }\n  }\n  if (command_obj.call_on_write) {\n    command_obj.call_on_write();\n  }\n  // Handle `CLIENT REPLY ON|OFF|SKIP`\n  // This has to be checked after call_on_write\n  /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n  if (this.reply === 'ON') {\n    this.command_queue.push(command_obj);\n  } else {\n    // Do not expect a reply\n    // Does this work in combination with the pub sub mode?\n    if (command_obj.callback) {\n      utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n    }\n    if (this.reply === 'SKIP') {\n      this.reply = 'SKIP_ONE_MORE';\n    } else if (this.reply === 'SKIP_ONE_MORE') {\n      this.reply = 'ON';\n    }\n  }\n  return !this.should_buffer;\n};\nRedisClient.prototype.write_strings = function () {\n  var str = '';\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n    if (str.length + command.length > 4 * 1024 * 1024) {\n      this.should_buffer = !this.stream.write(str);\n      str = '';\n    }\n    str += command;\n  }\n  if (str !== '') {\n    this.should_buffer = !this.stream.write(str);\n  }\n};\nRedisClient.prototype.write_buffers = function () {\n  for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n    this.should_buffer = !this.stream.write(command);\n  }\n};\nRedisClient.prototype.write = function (data) {\n  if (this.pipeline === false) {\n    this.should_buffer = !this.stream.write(data);\n    return;\n  }\n  this.pipeline_queue.push(data);\n};\nObject.defineProperty(exports, 'debugMode', {\n  get: function () {\n    return this.debug_mode;\n  },\n  set: function (val) {\n    this.debug_mode = val;\n  }\n});\n\n// Don't officially expose the command_queue directly but only the length as read only variable\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n});\n\n// Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n  get: function () {\n    return this.retry_delay;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n  get: function () {\n    return this.retry_backoff;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n  get: function () {\n    return this.command_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n  get: function () {\n    return this.offline_queue.length;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n  get: function () {\n    return this.should_buffer;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n  get: function () {\n    return this.connection_id;\n  }\n});\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n  get: function () {\n    return this.server_info;\n  }\n});\nexports.createClient = function () {\n  return new RedisClient(unifyOptions.apply(null, arguments));\n};\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = RedisErrors.RedisError;\nexports.ParserError = RedisErrors.ParserError;\nexports.ReplyError = RedisErrors.ReplyError;\nexports.AggregateError = errorClasses.AggregateError;\n\n// Add all redis commands / node_redis api to the client\nrequire('./lib/individualCommands');\nrequire('./lib/extendedApi');\n\n//enables adding new commands (for modules and new commands)\nexports.addCommand = exports.add_command = require('./lib/commands');","map":{"version":3,"names":["net","require","tls","util","utils","Command","Queue","errorClasses","EventEmitter","Parser","RedisErrors","commands","debug","unifyOptions","SUBSCRIBE_COMMANDS","subscribe","unsubscribe","psubscribe","punsubscribe","noop","handle_detect_buffers_reply","reply","command","buffer_args","message_buffers","reply_to_strings","reply_to_object","exports","debug_mode","test","process","env","NODE_DEBUG","RedisClient","options","stream","clone","call","cnx_options","self","tls_option","address","path","port","host","family","isIP","connection_options","connection_id","connected","ready","socket_keepalive","undefined","socket_initial_delay","rename_commands","toLowerCase","return_buffers","detect_buffers","warn","handle_reply","should_buffer","command_queue","offline_queue","pipeline_queue","connect_timeout","enable_offline_queue","initialize_retry_vars","pub_sub_mode","subscription_set","monitoring","closing","server_info","auth_pass","password","selected_db","db","fire_strings","pipeline","sub_commands_left","times_connected","buffers","create_stream","on","event","reply_parser","optionReturnBuffers","inherits","create_parser","returnReply","data","return_reply","returnError","err","return_error","returnFatalError","message","flush_and_error","code","error","queues","emit","returnBuffers","stringNumbers","string_numbers","prototype","removeAllListeners","destroy","connect","createConnection","setTimeout","retry_totaltime","connection_gone","connect_event","once","on_connect","buffer_from_socket","execute","on_error","hadError","drain","setNoDelay","auth","cork","uncork","retry_timer","retry_delay","retry_backoff","attempts","msg","nextTick","listeners","length","console","error_attributes","aggregated_errors","queue_names","i","replace","command_obj","shift","AbortError","stack","toUpperCase","args","origin","callback","push","AggregateError","errors","retry_strategy","emitted_end","setKeepAlive","no_ready_check","on_ready","ready_check","write_strings","write_buffers","internal_send_command","callback_count","Object","keys","disable_resubscribing","key","slice","indexOf","send_offline_queue","on_info_cmd","res","loading","master_link_status","loading_eta_seconds","retry_time","info","retry_connection","reconnect_params","delay","attempt","camel_case","totalRetryTime","timesConnected","total_retry_time","Math","round","why","retry_params","Error","errorMessage","retryError","end","retry_unfulfilled_commands","unshift","apply","toArray","clear","match","err_code","callback_or_emit","normal_reply","subscribe_unsubscribe","type","get","buffer","channel","toString","count","running_command","return_pub_sub","replyStr","Buffer","isBuffer","monitor_regex","timestamp","split","map","elem","Array","handle_offline_command","writable","reply_in_order","arg","prefix_keys","command_str","len","big_data","args_copy","domain","bind","from","Date","invalidArgError","undefinedArgError","prefix","getKeyIndexes","pop","byteLength","write","call_on_write","str","defineProperty","set","val","createClient","arguments","print","Multi","RedisError","ParserError","ReplyError","addCommand","add_command"],"sources":["C:/Users/Ethan/Desktop/Dream Game Site/v4/client/node_modules/redis/index.js"],"sourcesContent":["'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar utils = require('./lib/utils');\nvar Command = require('./lib/command');\nvar Queue = require('denque');\nvar errorClasses = require('./lib/customErrors');\nvar EventEmitter = require('events');\nvar Parser = require('redis-parser');\nvar RedisErrors = require('redis-errors');\nvar commands = require('redis-commands');\nvar debug = require('./lib/debug');\nvar unifyOptions = require('./lib/createClient');\nvar SUBSCRIBE_COMMANDS = {\n    subscribe: true,\n    unsubscribe: true,\n    psubscribe: true,\n    punsubscribe: true\n};\n\nfunction noop () {}\n\nfunction handle_detect_buffers_reply (reply, command, buffer_args) {\n    if (buffer_args === false || this.message_buffers) {\n        // If detect_buffers option was specified, then the reply from the parser will be a buffer.\n        // If this command did not use Buffer arguments, then convert the reply to Strings here.\n        reply = utils.reply_to_strings(reply);\n    }\n\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n}\n\nexports.debug_mode = /\\bredis\\b/i.test(process.env.NODE_DEBUG);\n\n// Attention: The second parameter might be removed at will and is not officially supported.\n// Do not rely on this\nfunction RedisClient (options, stream) {\n    // Copy the options so they are not mutated\n    options = utils.clone(options);\n    EventEmitter.call(this);\n    var cnx_options = {};\n    var self = this;\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    for (var tls_option in options.tls) {\n        cnx_options[tls_option] = options.tls[tls_option];\n        // Copy the tls options into the general options to make sure the address is set right\n        if (tls_option === 'port' || tls_option === 'host' || tls_option === 'path' || tls_option === 'family') {\n            options[tls_option] = options.tls[tls_option];\n        }\n    }\n    if (stream) {\n        // The stream from the outside is used so no connection from this side is triggered but from the server this client should talk to\n        // Reconnect etc won't work with this. This requires monkey patching to work, so it is not officially supported\n        options.stream = stream;\n        this.address = '\"Private stream\"';\n    } else if (options.path) {\n        cnx_options.path = options.path;\n        this.address = options.path;\n    } else {\n        cnx_options.port = +options.port || 6379;\n        cnx_options.host = options.host || '127.0.0.1';\n        cnx_options.family = (!options.family && net.isIP(cnx_options.host)) || (options.family === 'IPv6' ? 6 : 4);\n        this.address = cnx_options.host + ':' + cnx_options.port;\n    }\n\n    this.connection_options = cnx_options;\n    this.connection_id = RedisClient.connection_id++;\n    this.connected = false;\n    this.ready = false;\n    if (options.socket_keepalive === undefined) {\n        options.socket_keepalive = true;\n    }\n    if (options.socket_initial_delay === undefined) {\n        options.socket_initial_delay = 0;\n        // set default to 0, which is aligned to https://nodejs.org/api/net.html#net_socket_setkeepalive_enable_initialdelay\n    }\n    for (var command in options.rename_commands) {\n        options.rename_commands[command.toLowerCase()] = options.rename_commands[command];\n    }\n    options.return_buffers = !!options.return_buffers;\n    options.detect_buffers = !!options.detect_buffers;\n    // Override the detect_buffers setting if return_buffers is active and print a warning\n    if (options.return_buffers && options.detect_buffers) {\n        self.warn('WARNING: You activated return_buffers and detect_buffers at the same time. The return value is always going to be a buffer.');\n        options.detect_buffers = false;\n    }\n    if (options.detect_buffers) {\n        // We only need to look at the arguments if we do not know what we have to return\n        this.handle_reply = handle_detect_buffers_reply;\n    }\n    this.should_buffer = false;\n    this.command_queue = new Queue(); // Holds sent commands to de-pipeline them\n    this.offline_queue = new Queue(); // Holds commands issued but not able to be sent\n    this.pipeline_queue = new Queue(); // Holds all pipelined commands\n    // ATTENTION: connect_timeout should change in v.3.0 so it does not count towards ending reconnection attempts after x seconds\n    // This should be done by the retry_strategy. Instead it should only be the timeout for connecting to redis\n    this.connect_timeout = +options.connect_timeout || 3600000; // 60 * 60 * 1000 ms\n    this.enable_offline_queue = options.enable_offline_queue === false ? false : true;\n    this.initialize_retry_vars();\n    this.pub_sub_mode = 0;\n    this.subscription_set = {};\n    this.monitoring = false;\n    this.message_buffers = false;\n    this.closing = false;\n    this.server_info = {};\n    this.auth_pass = options.auth_pass || options.password;\n    this.selected_db = options.db; // Save the selected db here, used when reconnecting\n    this.fire_strings = true; // Determine if strings or buffers should be written to the stream\n    this.pipeline = false;\n    this.sub_commands_left = 0;\n    this.times_connected = 0;\n    this.buffers = options.return_buffers || options.detect_buffers;\n    this.options = options;\n    this.reply = 'ON'; // Returning replies is the default\n    this.create_stream();\n    // The listeners will not be attached right away, so let's print the deprecation message while the listener is attached\n    this.on('newListener', function (event) {\n        if ((event === 'message_buffer' || event === 'pmessage_buffer' || event === 'messageBuffer' || event === 'pmessageBuffer') && !this.buffers && !this.message_buffers) {\n            this.reply_parser.optionReturnBuffers = true;\n            this.message_buffers = true;\n            this.handle_reply = handle_detect_buffers_reply;\n        }\n    });\n}\nutil.inherits(RedisClient, EventEmitter);\n\nRedisClient.connection_id = 0;\n\nfunction create_parser (self) {\n    return new Parser({\n        returnReply: function (data) {\n            self.return_reply(data);\n        },\n        returnError: function (err) {\n            // Return a ReplyError to indicate Redis returned an error\n            self.return_error(err);\n        },\n        returnFatalError: function (err) {\n            // Error out all fired commands. Otherwise they might rely on faulty data. We have to reconnect to get in a working state again\n            // Note: the execution order is important. First flush and emit, then create the stream\n            err.message += '. Please report this.';\n            self.ready = false;\n            self.flush_and_error({\n                message: 'Fatal error encountered. Command aborted.',\n                code: 'NR_FATAL'\n            }, {\n                error: err,\n                queues: ['command_queue']\n            });\n            self.emit('error', err);\n            self.create_stream();\n        },\n        returnBuffers: self.buffers || self.message_buffers,\n        stringNumbers: self.options.string_numbers || false\n    });\n}\n\n/******************************************************************************\n\n    All functions in here are internal besides the RedisClient constructor\n    and the exported functions. Don't rely on them as they will be private\n    functions in node_redis v.3\n\n******************************************************************************/\n\n// Attention: the function name \"create_stream\" should not be changed, as other libraries need this to mock the stream (e.g. fakeredis)\nRedisClient.prototype.create_stream = function () {\n    var self = this;\n\n    // Init parser\n    this.reply_parser = create_parser(this);\n\n    if (this.options.stream) {\n        // Only add the listeners once in case of a reconnect try (that won't work)\n        if (this.stream) {\n            return;\n        }\n        this.stream = this.options.stream;\n    } else {\n        // On a reconnect destroy the former stream and retry\n        if (this.stream) {\n            this.stream.removeAllListeners();\n            this.stream.destroy();\n        }\n\n        /* istanbul ignore if: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n        if (this.options.tls) {\n            this.stream = tls.connect(this.connection_options);\n        } else {\n            this.stream = net.createConnection(this.connection_options);\n        }\n    }\n\n    if (this.options.connect_timeout) {\n        this.stream.setTimeout(this.connect_timeout, function () {\n            // Note: This is only tested if a internet connection is established\n            self.retry_totaltime = self.connect_timeout;\n            self.connection_gone('timeout');\n        });\n    }\n\n    /* istanbul ignore next: travis does not work with stunnel atm. Therefore the tls tests are skipped on travis */\n    var connect_event = this.options.tls ? 'secureConnect' : 'connect';\n    this.stream.once(connect_event, function () {\n        this.removeAllListeners('timeout');\n        self.times_connected++;\n        self.on_connect();\n    });\n\n    this.stream.on('data', function (buffer_from_socket) {\n        // The buffer_from_socket.toString() has a significant impact on big chunks and therefore this should only be used if necessary\n        debug('Net read ' + self.address + ' id ' + self.connection_id); // + ': ' + buffer_from_socket.toString());\n        self.reply_parser.execute(buffer_from_socket);\n    });\n\n    this.stream.on('error', function (err) {\n        self.on_error(err);\n    });\n\n    this.stream.once('close', function (hadError) {\n        self.connection_gone('close');\n    });\n\n    this.stream.once('end', function () {\n        self.connection_gone('end');\n    });\n\n    this.stream.on('drain', function () {\n        self.drain();\n    });\n\n    this.stream.setNoDelay();\n\n    // Fire the command before redis is connected to be sure it's the first fired command\n    if (this.auth_pass !== undefined) {\n        this.ready = true;\n        // Fail silently as we might not be able to connect\n        this.auth(this.auth_pass, function (err) {\n            if (err && err.code !== 'UNCERTAIN_STATE') {\n                self.emit('error', err);\n            }\n        });\n        this.ready = false;\n    }\n};\n\nRedisClient.prototype.handle_reply = function (reply, command) {\n    if (command === 'hgetall') {\n        reply = utils.reply_to_object(reply);\n    }\n    return reply;\n};\n\nRedisClient.prototype.cork = noop;\nRedisClient.prototype.uncork = noop;\n\nRedisClient.prototype.initialize_retry_vars = function () {\n    this.retry_timer = null;\n    this.retry_totaltime = 0;\n    this.retry_delay = 200;\n    this.retry_backoff = 1.7;\n    this.attempts = 1;\n};\n\nRedisClient.prototype.warn = function (msg) {\n    var self = this;\n    // Warn on the next tick. Otherwise no event listener can be added\n    // for warnings that are emitted in the redis client constructor\n    process.nextTick(function () {\n        if (self.listeners('warning').length !== 0) {\n            self.emit('warning', msg);\n        } else {\n            console.warn('node_redis:', msg);\n        }\n    });\n};\n\n// Flush provided queues, erroring any items with a callback first\nRedisClient.prototype.flush_and_error = function (error_attributes, options) {\n    options = options || {};\n    var aggregated_errors = [];\n    var queue_names = options.queues || ['command_queue', 'offline_queue']; // Flush the command_queue first to keep the order intakt\n    for (var i = 0; i < queue_names.length; i++) {\n        // If the command was fired it might have been processed so far\n        if (queue_names[i] === 'command_queue') {\n            error_attributes.message += ' It might have been processed.';\n        } else { // As the command_queue is flushed first, remove this for the offline queue\n            error_attributes.message = error_attributes.message.replace(' It might have been processed.', '');\n        }\n        // Don't flush everything from the queue\n        for (var command_obj = this[queue_names[i]].shift(); command_obj; command_obj = this[queue_names[i]].shift()) {\n            var err = new errorClasses.AbortError(error_attributes);\n            if (command_obj.error) {\n                err.stack = err.stack + command_obj.error.stack.replace(/^Error.*?\\n/, '\\n');\n            }\n            err.command = command_obj.command.toUpperCase();\n            if (command_obj.args && command_obj.args.length) {\n                err.args = command_obj.args;\n            }\n            if (options.error) {\n                err.origin = options.error;\n            }\n            if (typeof command_obj.callback === 'function') {\n                command_obj.callback(err);\n            } else {\n                aggregated_errors.push(err);\n            }\n        }\n    }\n    // Currently this would be a breaking change, therefore it's only emitted in debug_mode\n    if (exports.debug_mode && aggregated_errors.length) {\n        var error;\n        if (aggregated_errors.length === 1) {\n            error = aggregated_errors[0];\n        } else {\n            error_attributes.message = error_attributes.message.replace('It', 'They').replace(/command/i, '$&s');\n            error = new errorClasses.AggregateError(error_attributes);\n            error.errors = aggregated_errors;\n        }\n        this.emit('error', error);\n    }\n};\n\nRedisClient.prototype.on_error = function (err) {\n    if (this.closing) {\n        return;\n    }\n\n    err.message = 'Redis connection to ' + this.address + ' failed - ' + err.message;\n    debug(err.message);\n    this.connected = false;\n    this.ready = false;\n\n    // Only emit the error if the retry_strategy option is not set\n    if (!this.options.retry_strategy) {\n        this.emit('error', err);\n    }\n    // 'error' events get turned into exceptions if they aren't listened for. If the user handled this error\n    // then we should try to reconnect.\n    this.connection_gone('error', err);\n};\n\nRedisClient.prototype.on_connect = function () {\n    debug('Stream connected ' + this.address + ' id ' + this.connection_id);\n\n    this.connected = true;\n    this.ready = false;\n    this.emitted_end = false;\n    this.stream.setKeepAlive(this.options.socket_keepalive, this.options.socket_initial_delay);\n    this.stream.setTimeout(0);\n\n    this.emit('connect');\n    this.initialize_retry_vars();\n\n    if (this.options.no_ready_check) {\n        this.on_ready();\n    } else {\n        this.ready_check();\n    }\n};\n\nRedisClient.prototype.on_ready = function () {\n    var self = this;\n\n    debug('on_ready called ' + this.address + ' id ' + this.connection_id);\n    this.ready = true;\n\n    this.cork = function () {\n        self.pipeline = true;\n        if (self.stream.cork) {\n            self.stream.cork();\n        }\n    };\n    this.uncork = function () {\n        if (self.fire_strings) {\n            self.write_strings();\n        } else {\n            self.write_buffers();\n        }\n        self.pipeline = false;\n        self.fire_strings = true;\n        if (self.stream.uncork) {\n            // TODO: Consider using next tick here. See https://github.com/NodeRedis/node_redis/issues/1033\n            self.stream.uncork();\n        }\n    };\n\n    // Restore modal commands from previous connection. The order of the commands is important\n    if (this.selected_db !== undefined) {\n        this.internal_send_command(new Command('select', [this.selected_db]));\n    }\n    if (this.monitoring) { // Monitor has to be fired before pub sub commands\n        this.internal_send_command(new Command('monitor', []));\n    }\n    var callback_count = Object.keys(this.subscription_set).length;\n    if (!this.options.disable_resubscribing && callback_count) {\n        // only emit 'ready' when all subscriptions were made again\n        // TODO: Remove the countdown for ready here. This is not coherent with all other modes and should therefore not be handled special\n        // We know we are ready as soon as all commands were fired\n        var callback = function () {\n            callback_count--;\n            if (callback_count === 0) {\n                self.emit('ready');\n            }\n        };\n        debug('Sending pub/sub on_ready commands');\n        for (var key in this.subscription_set) {\n            var command = key.slice(0, key.indexOf('_'));\n            var args = this.subscription_set[key];\n            this[command]([args], callback);\n        }\n        this.send_offline_queue();\n        return;\n    }\n    this.send_offline_queue();\n    this.emit('ready');\n};\n\nRedisClient.prototype.on_info_cmd = function (err, res) {\n    if (err) {\n        if (err.message === \"ERR unknown command 'info'\") {\n            this.on_ready();\n            return;\n        }\n        err.message = 'Ready check failed: ' + err.message;\n        this.emit('error', err);\n        return;\n    }\n\n    /* istanbul ignore if: some servers might not respond with any info data. This is just a safety check that is difficult to test */\n    if (!res) {\n        debug('The info command returned without any data.');\n        this.on_ready();\n        return;\n    }\n\n    if (!this.server_info.loading || this.server_info.loading === '0') {\n        // If the master_link_status exists but the link is not up, try again after 50 ms\n        if (this.server_info.master_link_status && this.server_info.master_link_status !== 'up') {\n            this.server_info.loading_eta_seconds = 0.05;\n        } else {\n            // Eta loading should change\n            debug('Redis server ready.');\n            this.on_ready();\n            return;\n        }\n    }\n\n    var retry_time = +this.server_info.loading_eta_seconds * 1000;\n    if (retry_time > 1000) {\n        retry_time = 1000;\n    }\n    debug('Redis server still loading, trying again in ' + retry_time);\n    setTimeout(function (self) {\n        self.ready_check();\n    }, retry_time, this);\n};\n\nRedisClient.prototype.ready_check = function () {\n    var self = this;\n    debug('Checking server ready state...');\n    // Always fire this info command as first command even if other commands are already queued up\n    this.ready = true;\n    this.info(function (err, res) {\n        self.on_info_cmd(err, res);\n    });\n    this.ready = false;\n};\n\nRedisClient.prototype.send_offline_queue = function () {\n    for (var command_obj = this.offline_queue.shift(); command_obj; command_obj = this.offline_queue.shift()) {\n        debug('Sending offline command: ' + command_obj.command);\n        this.internal_send_command(command_obj);\n    }\n    this.drain();\n};\n\nvar retry_connection = function (self, error) {\n    debug('Retrying connection...');\n\n    var reconnect_params = {\n        delay: self.retry_delay,\n        attempt: self.attempts,\n        error: error\n    };\n    if (self.options.camel_case) {\n        reconnect_params.totalRetryTime = self.retry_totaltime;\n        reconnect_params.timesConnected = self.times_connected;\n    } else {\n        reconnect_params.total_retry_time = self.retry_totaltime;\n        reconnect_params.times_connected = self.times_connected;\n    }\n    self.emit('reconnecting', reconnect_params);\n\n    self.retry_totaltime += self.retry_delay;\n    self.attempts += 1;\n    self.retry_delay = Math.round(self.retry_delay * self.retry_backoff);\n    self.create_stream();\n    self.retry_timer = null;\n};\n\nRedisClient.prototype.connection_gone = function (why, error) {\n    // If a retry is already in progress, just let that happen\n    if (this.retry_timer) {\n        return;\n    }\n    error = error || null;\n\n    debug('Redis connection is gone from ' + why + ' event.');\n    this.connected = false;\n    this.ready = false;\n    // Deactivate cork to work with the offline queue\n    this.cork = noop;\n    this.uncork = noop;\n    this.pipeline = false;\n    this.pub_sub_mode = 0;\n\n    // since we are collapsing end and close, users don't expect to be called twice\n    if (!this.emitted_end) {\n        this.emit('end');\n        this.emitted_end = true;\n    }\n\n    // If this is a requested shutdown, then don't retry\n    if (this.closing) {\n        debug('Connection ended by quit / end command, not retrying.');\n        this.flush_and_error({\n            message: 'Stream connection ended and command aborted.',\n            code: 'NR_CLOSED'\n        }, {\n            error: error\n        });\n        return;\n    }\n\n    if (typeof this.options.retry_strategy === 'function') {\n        var retry_params = {\n            attempt: this.attempts,\n            error: error\n        };\n        if (this.options.camel_case) {\n            retry_params.totalRetryTime = this.retry_totaltime;\n            retry_params.timesConnected = this.times_connected;\n        } else {\n            retry_params.total_retry_time = this.retry_totaltime;\n            retry_params.times_connected = this.times_connected;\n        }\n        this.retry_delay = this.options.retry_strategy(retry_params);\n        if (typeof this.retry_delay !== 'number') {\n            // Pass individual error through\n            if (this.retry_delay instanceof Error) {\n                error = this.retry_delay;\n            }\n            var errorMessage = 'Redis connection in broken state: ';\n            if (this.retry_totaltime >= this.connect_timeout) {\n                errorMessage += 'connection timeout exceeded.';\n            } else {\n                errorMessage += 'maximum connection attempts exceeded.';\n            }\n\n            this.flush_and_error({\n                message: errorMessage,\n                code: 'CONNECTION_BROKEN',\n            }, {\n                error: error\n            });\n            var retryError = new Error(errorMessage);\n            retryError.code = 'CONNECTION_BROKEN';\n            if (error) {\n                retryError.origin = error;\n            }\n            this.end(false);\n            this.emit('error', retryError);\n            return;\n        }\n    }\n\n    if (this.retry_totaltime >= this.connect_timeout) {\n        var message = 'Redis connection in broken state: ';\n        if (this.retry_totaltime >= this.connect_timeout) {\n            message += 'connection timeout exceeded.';\n        } else {\n            message += 'maximum connection attempts exceeded.';\n        }\n\n        this.flush_and_error({\n            message: message,\n            code: 'CONNECTION_BROKEN',\n        }, {\n            error: error\n        });\n        var err = new Error(message);\n        err.code = 'CONNECTION_BROKEN';\n        if (error) {\n            err.origin = error;\n        }\n        this.end(false);\n        this.emit('error', err);\n        return;\n    }\n\n    // Retry commands after a reconnect instead of throwing an error. Use this with caution\n    if (this.options.retry_unfulfilled_commands) {\n        this.offline_queue.unshift.apply(this.offline_queue, this.command_queue.toArray());\n        this.command_queue.clear();\n    } else if (this.command_queue.length !== 0) {\n        this.flush_and_error({\n            message: 'Redis connection lost and command aborted.',\n            code: 'UNCERTAIN_STATE'\n        }, {\n            error: error,\n            queues: ['command_queue']\n        });\n    }\n\n    if (this.retry_totaltime + this.retry_delay > this.connect_timeout) {\n        // Do not exceed the maximum\n        this.retry_delay = this.connect_timeout - this.retry_totaltime;\n    }\n\n    debug('Retry connection in ' + this.retry_delay + ' ms');\n    this.retry_timer = setTimeout(retry_connection, this.retry_delay, this, error);\n};\n\nRedisClient.prototype.return_error = function (err) {\n    var command_obj = this.command_queue.shift();\n    if (command_obj.error) {\n        err.stack = command_obj.error.stack.replace(/^Error.*?\\n/, 'ReplyError: ' + err.message + '\\n');\n    }\n    err.command = command_obj.command.toUpperCase();\n    if (command_obj.args && command_obj.args.length) {\n        err.args = command_obj.args;\n    }\n\n    // Count down pub sub mode if in entering modus\n    if (this.pub_sub_mode > 1) {\n        this.pub_sub_mode--;\n    }\n\n    var match = err.message.match(utils.err_code);\n    // LUA script could return user errors that don't behave like all other errors!\n    if (match) {\n        err.code = match[1];\n    }\n\n    utils.callback_or_emit(this, command_obj.callback, err);\n};\n\nRedisClient.prototype.drain = function () {\n    this.should_buffer = false;\n};\n\nfunction normal_reply (self, reply) {\n    var command_obj = self.command_queue.shift();\n    if (typeof command_obj.callback === 'function') {\n        if (command_obj.command !== 'exec') {\n            reply = self.handle_reply(reply, command_obj.command, command_obj.buffer_args);\n        }\n        command_obj.callback(null, reply);\n    } else {\n        debug('No callback for reply');\n    }\n}\n\nfunction subscribe_unsubscribe (self, reply, type) {\n    // Subscribe commands take an optional callback and also emit an event, but only the _last_ response is included in the callback\n    // The pub sub commands return each argument in a separate return value and have to be handled that way\n    var command_obj = self.command_queue.get(0);\n    var buffer = self.options.return_buffers || self.options.detect_buffers && command_obj.buffer_args;\n    var channel = (buffer || reply[1] === null) ? reply[1] : reply[1].toString();\n    var count = +reply[2]; // Return the channel counter as number no matter if `string_numbers` is activated or not\n    debug(type, channel);\n\n    // Emit first, then return the callback\n    if (channel !== null) { // Do not emit or \"unsubscribe\" something if there was no channel to unsubscribe from\n        self.emit(type, channel, count);\n        if (type === 'subscribe' || type === 'psubscribe') {\n            self.subscription_set[type + '_' + channel] = channel;\n        } else {\n            type = type === 'unsubscribe' ? 'subscribe' : 'psubscribe'; // Make types consistent\n            delete self.subscription_set[type + '_' + channel];\n        }\n    }\n\n    if (command_obj.args.length === 1 || self.sub_commands_left === 1 || command_obj.args.length === 0 && (count === 0 || channel === null)) {\n        if (count === 0) { // unsubscribed from all channels\n            var running_command;\n            var i = 1;\n            self.pub_sub_mode = 0; // Deactivating pub sub mode\n            // This should be a rare case and therefore handling it this way should be good performance wise for the general case\n            while (running_command = self.command_queue.get(i)) {\n                if (SUBSCRIBE_COMMANDS[running_command.command]) {\n                    self.pub_sub_mode = i; // Entering pub sub mode again\n                    break;\n                }\n                i++;\n            }\n        }\n        self.command_queue.shift();\n        if (typeof command_obj.callback === 'function') {\n            // TODO: The current return value is pretty useless.\n            // Evaluate to change this in v.4 to return all subscribed / unsubscribed channels in an array including the number of channels subscribed too\n            command_obj.callback(null, channel);\n        }\n        self.sub_commands_left = 0;\n    } else {\n        if (self.sub_commands_left !== 0) {\n            self.sub_commands_left--;\n        } else {\n            self.sub_commands_left = command_obj.args.length ? command_obj.args.length - 1 : count;\n        }\n    }\n}\n\nfunction return_pub_sub (self, reply) {\n    var type = reply[0].toString();\n    if (type === 'message') { // channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n            self.emit('message', reply[1].toString(), reply[2].toString());\n            self.emit('message_buffer', reply[1], reply[2]);\n            self.emit('messageBuffer', reply[1], reply[2]);\n        } else {\n            self.emit('message', reply[1], reply[2]);\n        }\n    } else if (type === 'pmessage') { // pattern, channel, message\n        if (!self.options.return_buffers || self.message_buffers) { // backwards compatible. Refactor this in v.4 to always return a string on the normal emitter\n            self.emit('pmessage', reply[1].toString(), reply[2].toString(), reply[3].toString());\n            self.emit('pmessage_buffer', reply[1], reply[2], reply[3]);\n            self.emit('pmessageBuffer', reply[1], reply[2], reply[3]);\n        } else {\n            self.emit('pmessage', reply[1], reply[2], reply[3]);\n        }\n    } else {\n        subscribe_unsubscribe(self, reply, type);\n    }\n}\n\nRedisClient.prototype.return_reply = function (reply) {\n    if (this.monitoring) {\n        var replyStr;\n        if (this.buffers && Buffer.isBuffer(reply)) {\n            replyStr = reply.toString();\n        } else {\n            replyStr = reply;\n        }\n        // If in monitor mode, all normal commands are still working and we only want to emit the streamlined commands\n        if (typeof replyStr === 'string' && utils.monitor_regex.test(replyStr)) {\n            var timestamp = replyStr.slice(0, replyStr.indexOf(' '));\n            var args = replyStr.slice(replyStr.indexOf('\"') + 1, -1).split('\" \"').map(function (elem) {\n                return elem.replace(/\\\\\"/g, '\"');\n            });\n            this.emit('monitor', timestamp, args, replyStr);\n            return;\n        }\n    }\n    if (this.pub_sub_mode === 0) {\n        normal_reply(this, reply);\n    } else if (this.pub_sub_mode !== 1) {\n        this.pub_sub_mode--;\n        normal_reply(this, reply);\n    } else if (!(reply instanceof Array) || reply.length <= 2) {\n        // Only PING and QUIT are allowed in this context besides the pub sub commands\n        // Ping replies with ['pong', null|value] and quit with 'OK'\n        normal_reply(this, reply);\n    } else {\n        return_pub_sub(this, reply);\n    }\n};\n\nfunction handle_offline_command (self, command_obj) {\n    var command = command_obj.command;\n    var err, msg;\n    if (self.closing || !self.enable_offline_queue) {\n        command = command.toUpperCase();\n        if (!self.closing) {\n            if (self.stream.writable) {\n                msg = 'The connection is not yet established and the offline queue is deactivated.';\n            } else {\n                msg = 'Stream not writeable.';\n            }\n        } else {\n            msg = 'The connection is already closed.';\n        }\n        err = new errorClasses.AbortError({\n            message: command + \" can't be processed. \" + msg,\n            code: 'NR_CLOSED',\n            command: command\n        });\n        if (command_obj.args.length) {\n            err.args = command_obj.args;\n        }\n        utils.reply_in_order(self, command_obj.callback, err);\n    } else {\n        debug('Queueing ' + command + ' for next server connection.');\n        self.offline_queue.push(command_obj);\n    }\n    self.should_buffer = true;\n}\n\n// Do not call internal_send_command directly, if you are not absolutly certain it handles everything properly\n// e.g. monitor / info does not work with internal_send_command only\nRedisClient.prototype.internal_send_command = function (command_obj) {\n    var arg, prefix_keys;\n    var i = 0;\n    var command_str = '';\n    var args = command_obj.args;\n    var command = command_obj.command;\n    var len = args.length;\n    var big_data = false;\n    var args_copy = new Array(len);\n\n    if (process.domain && command_obj.callback) {\n        command_obj.callback = process.domain.bind(command_obj.callback);\n    }\n\n    if (this.ready === false || this.stream.writable === false) {\n        // Handle offline commands right away\n        handle_offline_command(this, command_obj);\n        return false; // Indicate buffering\n    }\n\n    for (i = 0; i < len; i += 1) {\n        if (typeof args[i] === 'string') {\n            // 30000 seemed to be a good value to switch to buffers after testing and checking the pros and cons\n            if (args[i].length > 30000) {\n                big_data = true;\n                args_copy[i] = Buffer.from(args[i], 'utf8');\n            } else {\n                args_copy[i] = args[i];\n            }\n        } else if (typeof args[i] === 'object') { // Checking for object instead of Buffer.isBuffer helps us finding data types that we can't handle properly\n            if (args[i] instanceof Date) { // Accept dates as valid input\n                args_copy[i] = args[i].toString();\n            } else if (Buffer.isBuffer(args[i])) {\n                args_copy[i] = args[i];\n                command_obj.buffer_args = true;\n                big_data = true;\n            } else {\n                var invalidArgError = new Error(\n                    'node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type.\\n' +\n                    'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.'\n                );\n                invalidArgError.command = command_obj.command.toUpperCase();\n                if (command_obj.args && command_obj.args.length) {\n                    invalidArgError.args = command_obj.args;\n                }\n                if (command_obj.callback) {\n                    command_obj.callback(invalidArgError);\n                    return false;\n                }\n                throw invalidArgError;\n            }\n        } else if (typeof args[i] === 'undefined') {\n            var undefinedArgError = new Error(\n                'node_redis: The ' + command.toUpperCase() + ' command contains a invalid argument type of \"undefined\".\\n' +\n                'Only strings, dates and buffers are accepted. Please update your code to use valid argument types.'\n            );\n            undefinedArgError.command = command_obj.command.toUpperCase();\n            if (command_obj.args && command_obj.args.length) {\n                undefinedArgError.args = command_obj.args;\n            }\n            if (command_obj.callback) {\n                command_obj.callback(undefinedArgError);\n                return false;\n            }\n            throw undefinedArgError;\n        } else {\n            // Seems like numbers are converted fast using string concatenation\n            args_copy[i] = '' + args[i];\n        }\n    }\n\n    if (this.options.prefix) {\n        prefix_keys = commands.getKeyIndexes(command, args_copy);\n        for (i = prefix_keys.pop(); i !== undefined; i = prefix_keys.pop()) {\n            args_copy[i] = this.options.prefix + args_copy[i];\n        }\n    }\n    if (this.options.rename_commands && this.options.rename_commands[command]) {\n        command = this.options.rename_commands[command];\n    }\n    // Always use 'Multi bulk commands', but if passed any Buffer args, then do multiple writes, one for each arg.\n    // This means that using Buffers in commands is going to be slower, so use Strings if you don't already have a Buffer.\n    command_str = '*' + (len + 1) + '\\r\\n$' + command.length + '\\r\\n' + command + '\\r\\n';\n\n    if (big_data === false) { // Build up a string and send entire command in one write\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            command_str += '$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n';\n        }\n        debug('Send ' + this.address + ' id ' + this.connection_id + ': ' + command_str);\n        this.write(command_str);\n    } else {\n        debug('Send command (' + command_str + ') has Buffer arguments');\n        this.fire_strings = false;\n        this.write(command_str);\n\n        for (i = 0; i < len; i += 1) {\n            arg = args_copy[i];\n            if (typeof arg === 'string') {\n                this.write('$' + Buffer.byteLength(arg) + '\\r\\n' + arg + '\\r\\n');\n            } else { // buffer\n                this.write('$' + arg.length + '\\r\\n');\n                this.write(arg);\n                this.write('\\r\\n');\n            }\n            debug('send_command: buffer send ' + arg.length + ' bytes');\n        }\n    }\n    if (command_obj.call_on_write) {\n        command_obj.call_on_write();\n    }\n    // Handle `CLIENT REPLY ON|OFF|SKIP`\n    // This has to be checked after call_on_write\n    /* istanbul ignore else: TODO: Remove this as soon as we test Redis 3.2 on travis */\n    if (this.reply === 'ON') {\n        this.command_queue.push(command_obj);\n    } else {\n        // Do not expect a reply\n        // Does this work in combination with the pub sub mode?\n        if (command_obj.callback) {\n            utils.reply_in_order(this, command_obj.callback, null, undefined, this.command_queue);\n        }\n        if (this.reply === 'SKIP') {\n            this.reply = 'SKIP_ONE_MORE';\n        } else if (this.reply === 'SKIP_ONE_MORE') {\n            this.reply = 'ON';\n        }\n    }\n    return !this.should_buffer;\n};\n\nRedisClient.prototype.write_strings = function () {\n    var str = '';\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        // Write to stream if the string is bigger than 4mb. The biggest string may be Math.pow(2, 28) - 15 chars long\n        if (str.length + command.length > 4 * 1024 * 1024) {\n            this.should_buffer = !this.stream.write(str);\n            str = '';\n        }\n        str += command;\n    }\n    if (str !== '') {\n        this.should_buffer = !this.stream.write(str);\n    }\n};\n\nRedisClient.prototype.write_buffers = function () {\n    for (var command = this.pipeline_queue.shift(); command; command = this.pipeline_queue.shift()) {\n        this.should_buffer = !this.stream.write(command);\n    }\n};\n\nRedisClient.prototype.write = function (data) {\n    if (this.pipeline === false) {\n        this.should_buffer = !this.stream.write(data);\n        return;\n    }\n    this.pipeline_queue.push(data);\n};\n\nObject.defineProperty(exports, 'debugMode', {\n    get: function () {\n        return this.debug_mode;\n    },\n    set: function (val) {\n        this.debug_mode = val;\n    }\n});\n\n// Don't officially expose the command_queue directly but only the length as read only variable\nObject.defineProperty(RedisClient.prototype, 'command_queue_length', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offline_queue_length', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\n// Add support for camelCase by adding read only properties to the client\n// All known exposed snake_case variables are added here\nObject.defineProperty(RedisClient.prototype, 'retryDelay', {\n    get: function () {\n        return this.retry_delay;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'retryBackoff', {\n    get: function () {\n        return this.retry_backoff;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'commandQueueLength', {\n    get: function () {\n        return this.command_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'offlineQueueLength', {\n    get: function () {\n        return this.offline_queue.length;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'shouldBuffer', {\n    get: function () {\n        return this.should_buffer;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'connectionId', {\n    get: function () {\n        return this.connection_id;\n    }\n});\n\nObject.defineProperty(RedisClient.prototype, 'serverInfo', {\n    get: function () {\n        return this.server_info;\n    }\n});\n\nexports.createClient = function () {\n    return new RedisClient(unifyOptions.apply(null, arguments));\n};\nexports.RedisClient = RedisClient;\nexports.print = utils.print;\nexports.Multi = require('./lib/multi');\nexports.AbortError = errorClasses.AbortError;\nexports.RedisError = RedisErrors.RedisError;\nexports.ParserError = RedisErrors.ParserError;\nexports.ReplyError = RedisErrors.ReplyError;\nexports.AggregateError = errorClasses.AggregateError;\n\n// Add all redis commands / node_redis api to the client\nrequire('./lib/individualCommands');\nrequire('./lib/extendedApi');\n\n//enables adding new commands (for modules and new commands)\nexports.addCommand = exports.add_command = require('./lib/commands');\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}