{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst commands_1 = require(\"@ioredis/commands\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst utils_1 = require(\"./utils\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */\nclass Command {\n  /**\n   * Creates an instance of Command.\n   * @param name Command name\n   * @param args An array of command arguments\n   * @param options\n   * @param callback The callback that handles the response.\n   * If omit, the response will be handled via Promise\n   */\n  constructor(name) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let callback = arguments.length > 3 ? arguments[3] : undefined;\n    this.name = name;\n    this.inTransaction = false;\n    this.isResolved = false;\n    this.transformed = false;\n    this.replyEncoding = options.replyEncoding;\n    this.errorStack = options.errorStack;\n    this.args = args.flat();\n    this.callback = callback;\n    this.initPromise();\n    if (options.keyPrefix) {\n      // @ts-expect-error\n      const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n      // @ts-expect-error\n      let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;\n      this._iterateKeys(key => {\n        if (key instanceof Buffer) {\n          if (keyPrefixBuffer === null) {\n            keyPrefixBuffer = Buffer.from(options.keyPrefix);\n          }\n          return Buffer.concat([keyPrefixBuffer, key]);\n        } else if (isBufferKeyPrefix) {\n          // @ts-expect-error\n          return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);\n        }\n        return options.keyPrefix + key;\n      });\n    }\n    if (options.readOnly) {\n      this.isReadOnly = true;\n    }\n  }\n  /**\n   * Check whether the command has the flag\n   */\n  static checkFlag(flagName, commandName) {\n    return !!this.getFlagMap()[flagName][commandName];\n  }\n  static setArgumentTransformer(name, func) {\n    this._transformer.argument[name] = func;\n  }\n  static setReplyTransformer(name, func) {\n    this._transformer.reply[name] = func;\n  }\n  static getFlagMap() {\n    if (!this.flagMap) {\n      this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n        map[flagName] = {};\n        Command.FLAGS[flagName].forEach(commandName => {\n          map[flagName][commandName] = true;\n        });\n        return map;\n      }, {});\n    }\n    return this.flagMap;\n  }\n  getSlot() {\n    if (typeof this.slot === \"undefined\") {\n      const key = this.getKeys()[0];\n      this.slot = key == null ? null : calculateSlot(key);\n    }\n    return this.slot;\n  }\n  getKeys() {\n    return this._iterateKeys();\n  }\n  /**\n   * Convert command to writable buffer or string\n   */\n  toWritable(_socket) {\n    let result;\n    const commandStr = \"*\" + (this.args.length + 1) + \"\\r\\n$\" + Buffer.byteLength(this.name) + \"\\r\\n\" + this.name + \"\\r\\n\";\n    if (this.bufferMode) {\n      const buffers = new MixedBuffers();\n      buffers.push(commandStr);\n      for (let i = 0; i < this.args.length; ++i) {\n        const arg = this.args[i];\n        if (arg instanceof Buffer) {\n          if (arg.length === 0) {\n            buffers.push(\"$0\\r\\n\\r\\n\");\n          } else {\n            buffers.push(\"$\" + arg.length + \"\\r\\n\");\n            buffers.push(arg);\n            buffers.push(\"\\r\\n\");\n          }\n        } else {\n          buffers.push(\"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\");\n        }\n      }\n      result = buffers.toBuffer();\n    } else {\n      result = commandStr;\n      for (let i = 0; i < this.args.length; ++i) {\n        const arg = this.args[i];\n        result += \"$\" + Buffer.byteLength(arg) + \"\\r\\n\" + arg + \"\\r\\n\";\n      }\n    }\n    return result;\n  }\n  stringifyArguments() {\n    for (let i = 0; i < this.args.length; ++i) {\n      const arg = this.args[i];\n      if (typeof arg === \"string\") {\n        // buffers and strings don't need any transformation\n      } else if (arg instanceof Buffer) {\n        this.bufferMode = true;\n      } else {\n        this.args[i] = (0, utils_1.toArg)(arg);\n      }\n    }\n  }\n  /**\n   * Convert buffer/buffer[] to string/string[],\n   * and apply reply transformer.\n   */\n  transformReply(result) {\n    if (this.replyEncoding) {\n      result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n    }\n    const transformer = Command._transformer.reply[this.name];\n    if (transformer) {\n      result = transformer(result);\n    }\n    return result;\n  }\n  /**\n   * Set the wait time before terminating the attempt to execute a command\n   * and generating an error.\n   */\n  setTimeout(ms) {\n    if (!this._commandTimeoutTimer) {\n      this._commandTimeoutTimer = setTimeout(() => {\n        if (!this.isResolved) {\n          this.reject(new Error(\"Command timed out\"));\n        }\n      }, ms);\n    }\n  }\n  initPromise() {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.transformed) {\n        this.transformed = true;\n        const transformer = Command._transformer.argument[this.name];\n        if (transformer) {\n          this.args = transformer(this.args);\n        }\n        this.stringifyArguments();\n      }\n      this.resolve = this._convertValue(resolve);\n      if (this.errorStack) {\n        this.reject = err => {\n          reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n        };\n      } else {\n        this.reject = reject;\n      }\n    });\n    this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n  }\n  /**\n   * Iterate through the command arguments that are considered keys.\n   */\n  _iterateKeys() {\n    let transform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : key => key;\n    if (typeof this.keys === \"undefined\") {\n      this.keys = [];\n      if ((0, commands_1.exists)(this.name)) {\n        // @ts-expect-error\n        const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);\n        for (const index of keyIndexes) {\n          this.args[index] = transform(this.args[index]);\n          this.keys.push(this.args[index]);\n        }\n      }\n    }\n    return this.keys;\n  }\n  /**\n   * Convert the value from buffer to the target encoding.\n   */\n  _convertValue(resolve) {\n    return value => {\n      try {\n        const existingTimer = this._commandTimeoutTimer;\n        if (existingTimer) {\n          clearTimeout(existingTimer);\n          delete this._commandTimeoutTimer;\n        }\n        resolve(this.transformReply(value));\n        this.isResolved = true;\n      } catch (err) {\n        this.reject(err);\n      }\n      return this.promise;\n    };\n  }\n}\nexports.default = Command;\nCommand.FLAGS = {\n  VALID_IN_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"unsubscribe\", \"punsubscribe\", \"ssubscribe\", \"sunsubscribe\", \"ping\", \"quit\"],\n  VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n  ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"ssubscribe\"],\n  EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\", \"sunsubscribe\"],\n  WILL_DISCONNECT: [\"quit\"]\n};\nCommand._transformer = {\n  argument: {},\n  reply: {}\n};\nconst msetArgumentTransformer = function (args) {\n  if (args.length === 1) {\n    if (args[0] instanceof Map) {\n      return (0, utils_1.convertMapToArray)(args[0]);\n    }\n    if (typeof args[0] === \"object\" && args[0] !== null) {\n      return (0, utils_1.convertObjectToArray)(args[0]);\n    }\n  }\n  return args;\n};\nconst hsetArgumentTransformer = function (args) {\n  if (args.length === 2) {\n    if (args[1] instanceof Map) {\n      return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));\n    }\n    if (typeof args[1] === \"object\" && args[1] !== null) {\n      return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));\n    }\n  }\n  return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n  if (Array.isArray(result)) {\n    const obj = {};\n    for (let i = 0; i < result.length; i += 2) {\n      const key = result[i];\n      const value = result[i + 1];\n      if (key in obj) {\n        // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n        // https://github.com/luin/ioredis/issues/1267\n        Object.defineProperty(obj, key, {\n          value,\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      } else {\n        obj[key] = value;\n      }\n    }\n    return obj;\n  }\n  return result;\n});\nclass MixedBuffers {\n  constructor() {\n    this.length = 0;\n    this.items = [];\n  }\n  push(x) {\n    this.length += Buffer.byteLength(x);\n    this.items.push(x);\n  }\n  toBuffer() {\n    const result = Buffer.allocUnsafe(this.length);\n    let offset = 0;\n    for (const item of this.items) {\n      const length = Buffer.byteLength(item);\n      Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);\n      offset += length;\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","commands_1","require","calculateSlot","standard_as_callback_1","utils_1","Command","constructor","name","args","arguments","length","undefined","options","callback","inTransaction","isResolved","transformed","replyEncoding","errorStack","flat","initPromise","keyPrefix","isBufferKeyPrefix","Buffer","keyPrefixBuffer","_iterateKeys","key","from","concat","String","readOnly","isReadOnly","checkFlag","flagName","commandName","getFlagMap","setArgumentTransformer","func","_transformer","argument","setReplyTransformer","reply","flagMap","keys","FLAGS","reduce","map","forEach","getSlot","slot","getKeys","toWritable","_socket","result","commandStr","byteLength","bufferMode","buffers","MixedBuffers","push","i","arg","toBuffer","stringifyArguments","toArg","transformReply","convertBufferToString","transformer","setTimeout","ms","_commandTimeoutTimer","reject","Error","promise","Promise","resolve","_convertValue","err","optimizeErrorStack","stack","__dirname","default","transform","exists","keyIndexes","getKeyIndexes","index","existingTimer","clearTimeout","VALID_IN_SUBSCRIBER_MODE","VALID_IN_MONITOR_MODE","ENTER_SUBSCRIBER_MODE","EXIT_SUBSCRIBER_MODE","WILL_DISCONNECT","msetArgumentTransformer","Map","convertMapToArray","convertObjectToArray","hsetArgumentTransformer","Array","isArray","obj","configurable","enumerable","writable","items","x","allocUnsafe","offset","item","isBuffer","copy","write"],"sources":["C:/Users/Ethan/Desktop/Dream Game Site/v4/client/node_modules/ioredis/built/Command.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands_1 = require(\"@ioredis/commands\");\nconst calculateSlot = require(\"cluster-key-slot\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst utils_1 = require(\"./utils\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */\nclass Command {\n    /**\n     * Creates an instance of Command.\n     * @param name Command name\n     * @param args An array of command arguments\n     * @param options\n     * @param callback The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     */\n    constructor(name, args = [], options = {}, callback) {\n        this.name = name;\n        this.inTransaction = false;\n        this.isResolved = false;\n        this.transformed = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = args.flat();\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            // @ts-expect-error\n            const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n            // @ts-expect-error\n            let keyPrefixBuffer = isBufferKeyPrefix\n                ? options.keyPrefix\n                : null;\n            this._iterateKeys((key) => {\n                if (key instanceof Buffer) {\n                    if (keyPrefixBuffer === null) {\n                        keyPrefixBuffer = Buffer.from(options.keyPrefix);\n                    }\n                    return Buffer.concat([keyPrefixBuffer, key]);\n                }\n                else if (isBufferKeyPrefix) {\n                    // @ts-expect-error\n                    return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);\n                }\n                return options.keyPrefix + key;\n            });\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    /**\n     * Check whether the command has the flag\n     */\n    static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach((commandName) => {\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Convert command to writable buffer or string\n     */\n    toWritable(_socket) {\n        let result;\n        const commandStr = \"*\" +\n            (this.args.length + 1) +\n            \"\\r\\n$\" +\n            Buffer.byteLength(this.name) +\n            \"\\r\\n\" +\n            this.name +\n            \"\\r\\n\";\n        if (this.bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    }\n                    else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                }\n                else {\n                    buffers.push(\"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        }\n        else {\n            result = commandStr;\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                result +=\n                    \"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for (let i = 0; i < this.args.length; ++i) {\n            const arg = this.args[i];\n            if (typeof arg === \"string\") {\n                // buffers and strings don't need any transformation\n            }\n            else if (arg instanceof Buffer) {\n                this.bufferMode = true;\n            }\n            else {\n                this.args[i] = (0, utils_1.toArg)(arg);\n            }\n        }\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     */\n    transformReply(result) {\n        if (this.replyEncoding) {\n            result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n    /**\n     * Set the wait time before terminating the attempt to execute a command\n     * and generating an error.\n     */\n    setTimeout(ms) {\n        if (!this._commandTimeoutTimer) {\n            this._commandTimeoutTimer = setTimeout(() => {\n                if (!this.isResolved) {\n                    this.reject(new Error(\"Command timed out\"));\n                }\n            }, ms);\n        }\n    }\n    initPromise() {\n        const promise = new Promise((resolve, reject) => {\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = (err) => {\n                    reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n                };\n            }\n            else {\n                this.reject = reject;\n            }\n        });\n        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     */\n    _iterateKeys(transform = (key) => key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if ((0, commands_1.exists)(this.name)) {\n                // @ts-expect-error\n                const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);\n                for (const index of keyIndexes) {\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     */\n    _convertValue(resolve) {\n        return (value) => {\n            try {\n                const existingTimer = this._commandTimeoutTimer;\n                if (existingTimer) {\n                    clearTimeout(existingTimer);\n                    delete this._commandTimeoutTimer;\n                }\n                resolve(this.transformReply(value));\n                this.isResolved = true;\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n}\nexports.default = Command;\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ssubscribe\",\n        \"sunsubscribe\",\n        \"ping\",\n        \"quit\",\n    ],\n    VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n    ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"ssubscribe\"],\n    EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\", \"sunsubscribe\"],\n    WILL_DISCONNECT: [\"quit\"],\n};\nCommand._transformer = {\n    argument: {},\n    reply: {},\n};\nconst msetArgumentTransformer = function (args) {\n    if (args.length === 1) {\n        if (args[0] instanceof Map) {\n            return (0, utils_1.convertMapToArray)(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return (0, utils_1.convertObjectToArray)(args[0]);\n        }\n    }\n    return args;\n};\nconst hsetArgumentTransformer = function (args) {\n    if (args.length === 2) {\n        if (args[1] instanceof Map) {\n            return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n    if (Array.isArray(result)) {\n        const obj = {};\n        for (let i = 0; i < result.length; i += 2) {\n            const key = result[i];\n            const value = result[i + 1];\n            if (key in obj) {\n                // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n                // https://github.com/luin/ioredis/issues/1267\n                Object.defineProperty(obj, key, {\n                    value,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true,\n                });\n            }\n            else {\n                obj[key] = value;\n            }\n        }\n        return obj;\n    }\n    return result;\n});\nclass MixedBuffers {\n    constructor() {\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items) {\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item)\n                ? item.copy(result, offset)\n                : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}