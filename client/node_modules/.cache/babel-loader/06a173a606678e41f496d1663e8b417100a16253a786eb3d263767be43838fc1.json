{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = void 0;\nconst command_options_1 = require(\"./command-options\");\nfunction attachCommands(_ref) {\n  let {\n    BaseClass,\n    commands,\n    executor\n  } = _ref;\n  for (const [name, command] of Object.entries(commands)) {\n    BaseClass.prototype[name] = function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return executor.call(this, command, args, name);\n    };\n  }\n}\nexports.attachCommands = attachCommands;\nfunction attachExtensions(config) {\n  let Commander;\n  if (config.modules) {\n    Commander = attachWithNamespaces({\n      BaseClass: config.BaseClass,\n      namespaces: config.modules,\n      executor: config.modulesExecutor\n    });\n  }\n  if (config.functions) {\n    Commander = attachWithNamespaces({\n      BaseClass: Commander ?? config.BaseClass,\n      namespaces: config.functions,\n      executor: config.functionsExecutor\n    });\n  }\n  if (config.scripts) {\n    Commander ?? (Commander = class extends config.BaseClass {});\n    attachCommands({\n      BaseClass: Commander,\n      commands: config.scripts,\n      executor: config.scriptsExecutor\n    });\n  }\n  return Commander ?? config.BaseClass;\n}\nexports.attachExtensions = attachExtensions;\nfunction attachWithNamespaces(_ref2) {\n  let {\n    BaseClass,\n    namespaces,\n    executor\n  } = _ref2;\n  const Commander = class extends BaseClass {\n    constructor() {\n      super(...arguments);\n      for (const namespace of Object.keys(namespaces)) {\n        this[namespace] = Object.create(this[namespace], {\n          self: {\n            value: this\n          }\n        });\n      }\n    }\n  };\n  for (const [namespace, commands] of Object.entries(namespaces)) {\n    Commander.prototype[namespace] = {};\n    for (const [name, command] of Object.entries(commands)) {\n      Commander.prototype[namespace][name] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return executor.call(this.self, command, args, name);\n      };\n    }\n  }\n  return Commander;\n}\nfunction transformCommandArguments(command, args) {\n  let options;\n  if ((0, command_options_1.isCommandOptions)(args[0])) {\n    options = args[0];\n    args = args.slice(1);\n  }\n  return {\n    jsArgs: args,\n    args: command.transformArguments(...args),\n    options\n  };\n}\nexports.transformCommandArguments = transformCommandArguments;\nfunction transformLegacyCommandArguments(args) {\n  return args.flat().map(arg => {\n    return typeof arg === 'number' || arg instanceof Date ? arg.toString() : arg;\n  });\n}\nexports.transformLegacyCommandArguments = transformLegacyCommandArguments;\nfunction transformCommandReply(command, rawReply, preserved) {\n  if (!command.transformReply) {\n    return rawReply;\n  }\n  return command.transformReply(rawReply, preserved);\n}\nexports.transformCommandReply = transformCommandReply;\nfunction fCallArguments(name, fn, args) {\n  const actualArgs = [fn.IS_READ_ONLY ? 'FCALL_RO' : 'FCALL', name];\n  if (fn.NUMBER_OF_KEYS !== undefined) {\n    actualArgs.push(fn.NUMBER_OF_KEYS.toString());\n  }\n  actualArgs.push(...args);\n  return actualArgs;\n}\nexports.fCallArguments = fCallArguments;","map":{"version":3,"names":["Object","defineProperty","exports","value","fCallArguments","transformCommandReply","transformLegacyCommandArguments","transformCommandArguments","attachExtensions","attachCommands","command_options_1","require","_ref","BaseClass","commands","executor","name","command","entries","prototype","_len","arguments","length","args","Array","_key","call","config","Commander","modules","attachWithNamespaces","namespaces","modulesExecutor","functions","functionsExecutor","scripts","scriptsExecutor","_ref2","constructor","namespace","keys","create","self","_len2","_key2","options","isCommandOptions","slice","jsArgs","transformArguments","flat","map","arg","Date","toString","rawReply","preserved","transformReply","fn","actualArgs","IS_READ_ONLY","NUMBER_OF_KEYS","undefined","push"],"sources":["C:/Users/Ethan/Desktop/Dream Game Site/v4/client/node_modules/@redis/client/dist/lib/commander.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fCallArguments = exports.transformCommandReply = exports.transformLegacyCommandArguments = exports.transformCommandArguments = exports.attachExtensions = exports.attachCommands = void 0;\nconst command_options_1 = require(\"./command-options\");\nfunction attachCommands({ BaseClass, commands, executor }) {\n    for (const [name, command] of Object.entries(commands)) {\n        BaseClass.prototype[name] = function (...args) {\n            return executor.call(this, command, args, name);\n        };\n    }\n}\nexports.attachCommands = attachCommands;\nfunction attachExtensions(config) {\n    let Commander;\n    if (config.modules) {\n        Commander = attachWithNamespaces({\n            BaseClass: config.BaseClass,\n            namespaces: config.modules,\n            executor: config.modulesExecutor\n        });\n    }\n    if (config.functions) {\n        Commander = attachWithNamespaces({\n            BaseClass: Commander ?? config.BaseClass,\n            namespaces: config.functions,\n            executor: config.functionsExecutor\n        });\n    }\n    if (config.scripts) {\n        Commander ?? (Commander = class extends config.BaseClass {\n        });\n        attachCommands({\n            BaseClass: Commander,\n            commands: config.scripts,\n            executor: config.scriptsExecutor\n        });\n    }\n    return Commander ?? config.BaseClass;\n}\nexports.attachExtensions = attachExtensions;\nfunction attachWithNamespaces({ BaseClass, namespaces, executor }) {\n    const Commander = class extends BaseClass {\n        constructor(...args) {\n            super(...args);\n            for (const namespace of Object.keys(namespaces)) {\n                this[namespace] = Object.create(this[namespace], {\n                    self: {\n                        value: this\n                    }\n                });\n            }\n        }\n    };\n    for (const [namespace, commands] of Object.entries(namespaces)) {\n        Commander.prototype[namespace] = {};\n        for (const [name, command] of Object.entries(commands)) {\n            Commander.prototype[namespace][name] = function (...args) {\n                return executor.call(this.self, command, args, name);\n            };\n        }\n    }\n    return Commander;\n}\nfunction transformCommandArguments(command, args) {\n    let options;\n    if ((0, command_options_1.isCommandOptions)(args[0])) {\n        options = args[0];\n        args = args.slice(1);\n    }\n    return {\n        jsArgs: args,\n        args: command.transformArguments(...args),\n        options\n    };\n}\nexports.transformCommandArguments = transformCommandArguments;\nfunction transformLegacyCommandArguments(args) {\n    return args.flat().map(arg => {\n        return typeof arg === 'number' || arg instanceof Date ?\n            arg.toString() :\n            arg;\n    });\n}\nexports.transformLegacyCommandArguments = transformLegacyCommandArguments;\nfunction transformCommandReply(command, rawReply, preserved) {\n    if (!command.transformReply) {\n        return rawReply;\n    }\n    return command.transformReply(rawReply, preserved);\n}\nexports.transformCommandReply = transformCommandReply;\nfunction fCallArguments(name, fn, args) {\n    const actualArgs = [\n        fn.IS_READ_ONLY ? 'FCALL_RO' : 'FCALL',\n        name\n    ];\n    if (fn.NUMBER_OF_KEYS !== undefined) {\n        actualArgs.push(fn.NUMBER_OF_KEYS.toString());\n    }\n    actualArgs.push(...args);\n    return actualArgs;\n}\nexports.fCallArguments = fCallArguments;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}