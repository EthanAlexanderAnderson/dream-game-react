{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst Command_1 = require(\"../Command\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst Redis_1 = require(\"../Redis\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst transaction_1 = require(\"../transaction\");\nconst utils_1 = require(\"../utils\");\nconst applyMixin_1 = require(\"../utils/applyMixin\");\nconst Commander_1 = require(\"../utils/Commander\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst util_1 = require(\"./util\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n  /**\n   * Creates an instance of Cluster.\n   */\n  constructor(startupNodes) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.slots = [];\n    /**\n     * @ignore\n     */\n    this._groupsIds = {};\n    /**\n     * @ignore\n     */\n    this._groupsBySlot = Array(16384);\n    /**\n     * @ignore\n     */\n    this.isCluster = true;\n    this.retryAttempts = 0;\n    this.delayQueue = new DelayQueue_1.default();\n    this.offlineQueue = new Deque();\n    this.isRefreshing = false;\n    this._autoPipelines = new Map();\n    this._runningAutoPipelines = new Set();\n    this._readyDelayedCallbacks = [];\n    /**\n     * Every time Cluster#connect() is called, this value will be\n     * auto-incrementing. The purpose of this value is used for\n     * discarding previous connect attampts when creating a new\n     * connection.\n     */\n    this.connectionEpoch = 0;\n    events_1.EventEmitter.call(this);\n    this.startupNodes = startupNodes;\n    this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n    if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {\n      this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n    }\n    // validate options\n    if (typeof this.options.scaleReads !== \"function\" && [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n      throw new Error('Invalid option scaleReads \"' + this.options.scaleReads + '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n    }\n    this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n    this.connectionPool.on(\"-node\", (redis, key) => {\n      this.emit(\"-node\", redis);\n    });\n    this.connectionPool.on(\"+node\", redis => {\n      this.emit(\"+node\", redis);\n    });\n    this.connectionPool.on(\"drain\", () => {\n      this.setStatus(\"close\");\n    });\n    this.connectionPool.on(\"nodeError\", (error, key) => {\n      this.emit(\"node error\", error, key);\n    });\n    this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n    if (this.options.scripts) {\n      Object.entries(this.options.scripts).forEach(_ref => {\n        let [name, definition] = _ref;\n        this.defineCommand(name, definition);\n      });\n    }\n    if (this.options.lazyConnect) {\n      this.setStatus(\"wait\");\n    } else {\n      this.connect().catch(err => {\n        debug(\"connecting failed: %s\", err);\n      });\n    }\n  }\n  /**\n   * Connect to a cluster\n   */\n  connect() {\n    return new Promise((resolve, reject) => {\n      if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n        reject(new Error(\"Redis is already connecting/connected\"));\n        return;\n      }\n      const epoch = ++this.connectionEpoch;\n      this.setStatus(\"connecting\");\n      this.resolveStartupNodeHostnames().then(nodes => {\n        if (this.connectionEpoch !== epoch) {\n          debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n          reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n          return;\n        }\n        if (this.status !== \"connecting\") {\n          debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n          reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n          return;\n        }\n        this.connectionPool.reset(nodes);\n        const readyHandler = () => {\n          this.setStatus(\"ready\");\n          this.retryAttempts = 0;\n          this.executeOfflineCommands();\n          this.resetNodesRefreshInterval();\n          resolve();\n        };\n        let closeListener = undefined;\n        const refreshListener = () => {\n          this.invokeReadyDelayedCallbacks(undefined);\n          this.removeListener(\"close\", closeListener);\n          this.manuallyClosing = false;\n          this.setStatus(\"connect\");\n          if (this.options.enableReadyCheck) {\n            this.readyCheck((err, fail) => {\n              if (err || fail) {\n                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                if (this.status === \"connect\") {\n                  this.disconnect(true);\n                }\n              } else {\n                readyHandler();\n              }\n            });\n          } else {\n            readyHandler();\n          }\n        };\n        closeListener = () => {\n          const error = new Error(\"None of startup nodes is available\");\n          this.removeListener(\"refresh\", refreshListener);\n          this.invokeReadyDelayedCallbacks(error);\n          reject(error);\n        };\n        this.once(\"refresh\", refreshListener);\n        this.once(\"close\", closeListener);\n        this.once(\"close\", this.handleCloseEvent.bind(this));\n        this.refreshSlotsCache(err => {\n          if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n            Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n            this.connectionPool.reset([]);\n          }\n        });\n        this.subscriber.start();\n      }).catch(err => {\n        this.setStatus(\"close\");\n        this.handleCloseEvent(err);\n        this.invokeReadyDelayedCallbacks(err);\n        reject(err);\n      });\n    });\n  }\n  /**\n   * Disconnect from every node in the cluster.\n   */\n  disconnect() {\n    let reconnect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n    if (!reconnect) {\n      this.manuallyClosing = true;\n    }\n    if (this.reconnectTimeout && !reconnect) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n      debug(\"Canceled reconnecting attempts\");\n    }\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n    if (status === \"wait\") {\n      this.setStatus(\"close\");\n      this.handleCloseEvent();\n    } else {\n      this.connectionPool.reset([]);\n    }\n  }\n  /**\n   * Quit the cluster gracefully.\n   */\n  quit(callback) {\n    const status = this.status;\n    this.setStatus(\"disconnecting\");\n    this.manuallyClosing = true;\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    this.clearNodesRefreshInterval();\n    this.subscriber.stop();\n    if (status === \"wait\") {\n      const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n      // use setImmediate to make sure \"close\" event\n      // being emitted after quit() is returned\n      setImmediate(function () {\n        this.setStatus(\"close\");\n        this.handleCloseEvent();\n      }.bind(this));\n      return ret;\n    }\n    return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map(node => node.quit().catch(err => {\n      // Ignore the error caused by disconnecting since\n      // we're disconnecting...\n      if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n        return \"OK\";\n      }\n      throw err;\n    }))).then(() => \"OK\"), callback);\n  }\n  /**\n   * Create a new instance with the same startup nodes and options as the current one.\n   *\n   * @example\n   * ```js\n   * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n   * var anotherCluster = cluster.duplicate();\n   * ```\n   */\n  duplicate() {\n    let overrideStartupNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let overrideOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);\n    const options = Object.assign({}, this.options, overrideOptions);\n    return new Cluster(startupNodes, options);\n  }\n  /**\n   * Get nodes with the specified role\n   */\n  nodes() {\n    let role = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"all\";\n    if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n      throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n    }\n    return this.connectionPool.getNodes(role);\n  }\n  /**\n   * This is needed in order not to install a listener for each auto pipeline\n   *\n   * @ignore\n   */\n  delayUntilReady(callback) {\n    this._readyDelayedCallbacks.push(callback);\n  }\n  /**\n   * Get the number of commands queued in automatic pipelines.\n   *\n   * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n   */\n  get autoPipelineQueueSize() {\n    let queued = 0;\n    for (const pipeline of this._autoPipelines.values()) {\n      queued += pipeline.length;\n    }\n    return queued;\n  }\n  /**\n   * Refresh the slot cache\n   *\n   * @ignore\n   */\n  refreshSlotsCache(callback) {\n    if (this.isRefreshing) {\n      if (callback) {\n        process.nextTick(callback);\n      }\n      return;\n    }\n    this.isRefreshing = true;\n    const _this = this;\n    const wrapper = error => {\n      this.isRefreshing = false;\n      if (callback) {\n        callback(error);\n      }\n    };\n    const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n    let lastNodeError = null;\n    function tryNode(index) {\n      if (index === nodes.length) {\n        const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n        return wrapper(error);\n      }\n      const node = nodes[index];\n      const key = `${node.options.host}:${node.options.port}`;\n      debug(\"getting slot cache from %s\", key);\n      _this.getInfoFromNode(node, function (err) {\n        switch (_this.status) {\n          case \"close\":\n          case \"end\":\n            return wrapper(new Error(\"Cluster is disconnected.\"));\n          case \"disconnecting\":\n            return wrapper(new Error(\"Cluster is disconnecting.\"));\n        }\n        if (err) {\n          _this.emit(\"node error\", err, key);\n          lastNodeError = err;\n          tryNode(index + 1);\n        } else {\n          _this.emit(\"refresh\");\n          wrapper();\n        }\n      });\n    }\n    tryNode(0);\n  }\n  /**\n   * @ignore\n   */\n  sendCommand(command, stream, node) {\n    if (this.status === \"wait\") {\n      this.connect().catch(utils_1.noop);\n    }\n    if (this.status === \"end\") {\n      command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n      return command.promise;\n    }\n    let to = this.options.scaleReads;\n    if (to !== \"master\") {\n      const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n      if (!isCommandReadOnly) {\n        to = \"master\";\n      }\n    }\n    let targetSlot = node ? node.slot : command.getSlot();\n    const ttl = {};\n    const _this = this;\n    if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n      REJECT_OVERWRITTEN_COMMANDS.add(command);\n      const reject = command.reject;\n      command.reject = function (err) {\n        const partialTry = tryConnection.bind(null, true);\n        _this.handleError(err, ttl, {\n          moved: function (slot, key) {\n            debug(\"command %s is moved to %s\", command.name, key);\n            targetSlot = Number(slot);\n            if (_this.slots[slot]) {\n              _this.slots[slot][0] = key;\n            } else {\n              _this.slots[slot] = [key];\n            }\n            _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(\";\")];\n            _this.connectionPool.findOrCreate(_this.natMapper(key));\n            tryConnection();\n            debug(\"refreshing slot caches... (triggered by MOVED error)\");\n            _this.refreshSlotsCache();\n          },\n          ask: function (slot, key) {\n            debug(\"command %s is required to ask %s:%s\", command.name, key);\n            const mapped = _this.natMapper(key);\n            _this.connectionPool.findOrCreate(mapped);\n            tryConnection(false, `${mapped.host}:${mapped.port}`);\n          },\n          tryagain: partialTry,\n          clusterDown: partialTry,\n          connectionClosed: partialTry,\n          maxRedirections: function (redirectionError) {\n            reject.call(command, redirectionError);\n          },\n          defaults: function () {\n            reject.call(command, err);\n          }\n        });\n      };\n    }\n    tryConnection();\n    function tryConnection(random, asking) {\n      if (_this.status === \"end\") {\n        command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n        return;\n      }\n      let redis;\n      if (_this.status === \"ready\" || command.name === \"cluster\") {\n        if (node && node.redis) {\n          redis = node.redis;\n        } else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) || Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n          redis = _this.subscriber.getInstance();\n          if (!redis) {\n            command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n            return;\n          }\n        } else {\n          if (!random) {\n            if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n              const nodeKeys = _this.slots[targetSlot];\n              if (typeof to === \"function\") {\n                const nodes = nodeKeys.map(function (key) {\n                  return _this.connectionPool.getInstanceByKey(key);\n                });\n                redis = to(nodes, command);\n                if (Array.isArray(redis)) {\n                  redis = (0, utils_1.sample)(redis);\n                }\n                if (!redis) {\n                  redis = nodes[0];\n                }\n              } else {\n                let key;\n                if (to === \"all\") {\n                  key = (0, utils_1.sample)(nodeKeys);\n                } else if (to === \"slave\" && nodeKeys.length > 1) {\n                  key = (0, utils_1.sample)(nodeKeys, 1);\n                } else {\n                  key = nodeKeys[0];\n                }\n                redis = _this.connectionPool.getInstanceByKey(key);\n              }\n            }\n            if (asking) {\n              redis = _this.connectionPool.getInstanceByKey(asking);\n              redis.asking();\n            }\n          }\n          if (!redis) {\n            redis = (typeof to === \"function\" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance(\"all\");\n          }\n        }\n        if (node && !node.redis) {\n          node.redis = redis;\n        }\n      }\n      if (redis) {\n        redis.sendCommand(command, stream);\n      } else if (_this.options.enableOfflineQueue) {\n        _this.offlineQueue.push({\n          command: command,\n          stream: stream,\n          node: node\n        });\n      } else {\n        command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n      }\n    }\n    return command.promise;\n  }\n  sscanStream(key, options) {\n    return this.createScanStream(\"sscan\", {\n      key,\n      options\n    });\n  }\n  sscanBufferStream(key, options) {\n    return this.createScanStream(\"sscanBuffer\", {\n      key,\n      options\n    });\n  }\n  hscanStream(key, options) {\n    return this.createScanStream(\"hscan\", {\n      key,\n      options\n    });\n  }\n  hscanBufferStream(key, options) {\n    return this.createScanStream(\"hscanBuffer\", {\n      key,\n      options\n    });\n  }\n  zscanStream(key, options) {\n    return this.createScanStream(\"zscan\", {\n      key,\n      options\n    });\n  }\n  zscanBufferStream(key, options) {\n    return this.createScanStream(\"zscanBuffer\", {\n      key,\n      options\n    });\n  }\n  /**\n   * @ignore\n   */\n  handleError(error, ttl, handlers) {\n    if (typeof ttl.value === \"undefined\") {\n      ttl.value = this.options.maxRedirections;\n    } else {\n      ttl.value -= 1;\n    }\n    if (ttl.value <= 0) {\n      handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n      return;\n    }\n    const errv = error.message.split(\" \");\n    if (errv[0] === \"MOVED\") {\n      const timeout = this.options.retryDelayOnMoved;\n      if (timeout && typeof timeout === \"number\") {\n        this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), {\n          timeout\n        });\n      } else {\n        handlers.moved(errv[1], errv[2]);\n      }\n    } else if (errv[0] === \"ASK\") {\n      handlers.ask(errv[1], errv[2]);\n    } else if (errv[0] === \"TRYAGAIN\") {\n      this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n        timeout: this.options.retryDelayOnTryAgain\n      });\n    } else if (errv[0] === \"CLUSTERDOWN\" && this.options.retryDelayOnClusterDown > 0) {\n      this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnClusterDown,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === \"ready\") {\n      this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n        timeout: this.options.retryDelayOnFailover,\n        callback: this.refreshSlotsCache.bind(this)\n      });\n    } else {\n      handlers.defaults();\n    }\n  }\n  resetOfflineQueue() {\n    this.offlineQueue = new Deque();\n  }\n  clearNodesRefreshInterval() {\n    if (this.slotsTimer) {\n      clearTimeout(this.slotsTimer);\n      this.slotsTimer = null;\n    }\n  }\n  resetNodesRefreshInterval() {\n    if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n      return;\n    }\n    const nextRound = () => {\n      this.slotsTimer = setTimeout(() => {\n        debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n        this.refreshSlotsCache(() => {\n          nextRound();\n        });\n      }, this.options.slotsRefreshInterval);\n    };\n    nextRound();\n  }\n  /**\n   * Change cluster instance's status\n   */\n  setStatus(status) {\n    debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n    this.status = status;\n    process.nextTick(() => {\n      this.emit(status);\n    });\n  }\n  /**\n   * Called when closed to check whether a reconnection should be made\n   */\n  handleCloseEvent(reason) {\n    if (reason) {\n      debug(\"closed because %s\", reason);\n    }\n    let retryDelay;\n    if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === \"function\") {\n      retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n    }\n    if (typeof retryDelay === \"number\") {\n      this.setStatus(\"reconnecting\");\n      this.reconnectTimeout = setTimeout(() => {\n        this.reconnectTimeout = null;\n        debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n        this.connect().catch(function (err) {\n          debug(\"Got error %s when reconnecting. Ignoring...\", err);\n        });\n      }, retryDelay);\n    } else {\n      this.setStatus(\"end\");\n      this.flushQueue(new Error(\"None of startup nodes is available\"));\n    }\n  }\n  /**\n   * Flush offline queue with error.\n   */\n  flushQueue(error) {\n    let item;\n    while (item = this.offlineQueue.shift()) {\n      item.command.reject(error);\n    }\n  }\n  executeOfflineCommands() {\n    if (this.offlineQueue.length) {\n      debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n      const offlineQueue = this.offlineQueue;\n      this.resetOfflineQueue();\n      let item;\n      while (item = offlineQueue.shift()) {\n        this.sendCommand(item.command, item.stream, item.node);\n      }\n    }\n  }\n  natMapper(nodeKey) {\n    if (this.options.natMap && typeof this.options.natMap === \"object\") {\n      const key = typeof nodeKey === \"string\" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;\n      const mapped = this.options.natMap[key];\n      if (mapped) {\n        debug(\"NAT mapping %s -> %O\", key, mapped);\n        return Object.assign({}, mapped);\n      }\n    }\n    return typeof nodeKey === \"string\" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;\n  }\n  getInfoFromNode(redis, callback) {\n    if (!redis) {\n      return callback(new Error(\"Node is disconnected\"));\n    }\n    // Use a duplication of the connection to avoid\n    // timeouts when the connection is in the blocking\n    // mode (e.g. waiting for BLPOP).\n    const duplicatedConnection = redis.duplicate({\n      enableOfflineQueue: true,\n      enableReadyCheck: false,\n      retryStrategy: null,\n      connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName)\n    });\n    // Ignore error events since we will handle\n    // exceptions for the CLUSTER SLOTS command.\n    duplicatedConnection.on(\"error\", utils_1.noop);\n    duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n      duplicatedConnection.disconnect();\n      if (err) {\n        return callback(err);\n      }\n      if (this.status === \"disconnecting\" || this.status === \"close\" || this.status === \"end\") {\n        debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n        callback();\n        return;\n      }\n      const nodes = [];\n      debug(\"cluster slots result count: %d\", result.length);\n      for (let i = 0; i < result.length; ++i) {\n        const items = result[i];\n        const slotRangeStart = items[0];\n        const slotRangeEnd = items[1];\n        const keys = [];\n        for (let j = 2; j < items.length; j++) {\n          if (!items[j][0]) {\n            continue;\n          }\n          const node = this.natMapper({\n            host: items[j][0],\n            port: items[j][1]\n          });\n          node.readOnly = j !== 2;\n          nodes.push(node);\n          keys.push(node.host + \":\" + node.port);\n        }\n        debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n        for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n          this.slots[slot] = keys;\n        }\n      }\n      // Assign to each node keys a numeric value to make autopipeline comparison faster.\n      this._groupsIds = Object.create(null);\n      let j = 0;\n      for (let i = 0; i < 16384; i++) {\n        const target = (this.slots[i] || []).join(\";\");\n        if (!target.length) {\n          this._groupsBySlot[i] = undefined;\n          continue;\n        }\n        if (!this._groupsIds[target]) {\n          this._groupsIds[target] = ++j;\n        }\n        this._groupsBySlot[i] = this._groupsIds[target];\n      }\n      this.connectionPool.reset(nodes);\n      callback();\n    }, this.options.slotsRefreshTimeout));\n  }\n  invokeReadyDelayedCallbacks(err) {\n    for (const c of this._readyDelayedCallbacks) {\n      process.nextTick(c, err);\n    }\n    this._readyDelayedCallbacks = [];\n  }\n  /**\n   * Check whether Cluster is able to process commands\n   */\n  readyCheck(callback) {\n    this.cluster(\"INFO\", (err, res) => {\n      if (err) {\n        return callback(err);\n      }\n      if (typeof res !== \"string\") {\n        return callback();\n      }\n      let state;\n      const lines = res.split(\"\\r\\n\");\n      for (let i = 0; i < lines.length; ++i) {\n        const parts = lines[i].split(\":\");\n        if (parts[0] === \"cluster_state\") {\n          state = parts[1];\n          break;\n        }\n      }\n      if (state === \"fail\") {\n        debug(\"cluster state not ok (%s)\", state);\n        callback(null, state);\n      } else {\n        callback();\n      }\n    });\n  }\n  resolveSrv(hostname) {\n    return new Promise((resolve, reject) => {\n      this.options.resolveSrv(hostname, (err, records) => {\n        if (err) {\n          return reject(err);\n        }\n        const self = this,\n          groupedRecords = (0, util_1.groupSrvRecords)(records),\n          sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n        function tryFirstOne(err) {\n          if (!sortedKeys.length) {\n            return reject(err);\n          }\n          const key = sortedKeys[0],\n            group = groupedRecords[key],\n            record = (0, util_1.weightSrvRecords)(group);\n          if (!group.records.length) {\n            sortedKeys.shift();\n          }\n          self.dnsLookup(record.name).then(host => resolve({\n            host,\n            port: record.port\n          }), tryFirstOne);\n        }\n        tryFirstOne();\n      });\n    });\n  }\n  dnsLookup(hostname) {\n    return new Promise((resolve, reject) => {\n      this.options.dnsLookup(hostname, (err, address) => {\n        if (err) {\n          debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n          reject(err);\n        } else {\n          debug(\"resolved hostname %s to IP %s\", hostname, address);\n          resolve(address);\n        }\n      });\n    });\n  }\n  /**\n   * Normalize startup nodes, and resolving hostnames to IPs.\n   *\n   * This process happens every time when #connect() is called since\n   * #startupNodes and DNS records may chanage.\n   */\n  async resolveStartupNodeHostnames() {\n    if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n      throw new Error(\"`startupNodes` should contain at least one node.\");\n    }\n    const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n    const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n    if (hostnames.length === 0) {\n      return startupNodes;\n    }\n    const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n    const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n    return startupNodes.map(node => {\n      const config = hostnameToConfig.get(node.host);\n      if (!config) {\n        return node;\n      }\n      if (this.options.useSRVRecords) {\n        return Object.assign({}, node, config);\n      }\n      return Object.assign({}, node, {\n        host: config\n      });\n    });\n  }\n  createScanStream(command, _ref2) {\n    let {\n      key,\n      options = {}\n    } = _ref2;\n    return new ScanStream_1.default({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command,\n      ...options\n    });\n  }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports.default = Cluster;","map":{"version":3,"names":["Object","defineProperty","exports","value","commands_1","require","events_1","redis_errors_1","standard_as_callback_1","Command_1","ClusterAllFailedError_1","Redis_1","ScanStream_1","transaction_1","utils_1","applyMixin_1","Commander_1","ClusterOptions_1","ClusterSubscriber_1","ConnectionPool_1","DelayQueue_1","util_1","Deque","debug","Debug","REJECT_OVERWRITTEN_COMMANDS","WeakSet","Cluster","default","constructor","startupNodes","options","arguments","length","undefined","slots","_groupsIds","_groupsBySlot","Array","isCluster","retryAttempts","delayQueue","offlineQueue","isRefreshing","_autoPipelines","Map","_runningAutoPipelines","Set","_readyDelayedCallbacks","connectionEpoch","EventEmitter","call","defaults","DEFAULT_CLUSTER_OPTIONS","redisOptions","keyPrefix","scaleReads","indexOf","Error","connectionPool","on","redis","key","emit","setStatus","error","subscriber","scripts","entries","forEach","_ref","name","definition","defineCommand","lazyConnect","connect","catch","err","Promise","resolve","reject","status","epoch","resolveStartupNodeHostnames","then","nodes","RedisError","reset","readyHandler","executeOfflineCommands","resetNodesRefreshInterval","closeListener","refreshListener","invokeReadyDelayedCallbacks","removeListener","manuallyClosing","enableReadyCheck","readyCheck","fail","disconnect","once","handleCloseEvent","bind","refreshSlotsCache","message","defaultMessage","prototype","silentEmit","start","reconnect","reconnectTimeout","clearTimeout","clearNodesRefreshInterval","stop","quit","callback","ret","setImmediate","all","map","node","CONNECTION_CLOSED_ERROR_MSG","duplicate","overrideStartupNodes","overrideOptions","slice","assign","role","getNodes","delayUntilReady","push","autoPipelineQueueSize","queued","pipeline","values","process","nextTick","_this","wrapper","shuffle","lastNodeError","tryNode","index","host","port","getInfoFromNode","sendCommand","command","stream","noop","promise","to","isCommandReadOnly","isReadOnly","exists","hasFlag","targetSlot","slot","getSlot","ttl","has","add","partialTry","tryConnection","handleError","moved","Number","join","findOrCreate","natMapper","ask","mapped","tryagain","clusterDown","connectionClosed","maxRedirections","redirectionError","random","asking","AbortError","checkFlag","getInstance","nodeKeys","getInstanceByKey","isArray","sample","getSampleInstance","enableOfflineQueue","sscanStream","createScanStream","sscanBufferStream","hscanStream","hscanBufferStream","zscanStream","zscanBufferStream","handlers","errv","split","timeout","retryDelayOnMoved","retryDelayOnTryAgain","retryDelayOnClusterDown","retryDelayOnFailover","resetOfflineQueue","slotsTimer","slotsRefreshInterval","nextRound","setTimeout","reason","retryDelay","clusterRetryStrategy","flushQueue","item","shift","nodeKey","natMap","nodeKeyToRedisOptions","duplicatedConnection","retryStrategy","connectionName","getConnectionName","cluster","result","i","items","slotRangeStart","slotRangeEnd","keys","j","readOnly","create","target","slotsRefreshTimeout","c","res","state","lines","parts","resolveSrv","hostname","records","self","groupedRecords","groupSrvRecords","sortedKeys","sort","a","b","parseInt","tryFirstOne","group","record","weightSrvRecords","dnsLookup","address","normalizeNodeOptions","hostnames","getUniqueHostnamesFromOptions","configs","useSRVRecords","hostnameToConfig","zipMap","config","get","_ref2","objectMode","addTransactionSupport"],"sources":["C:/Users/Ethan/Desktop/Dream Game Site/v4/client/node_modules/ioredis/built/cluster/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst redis_errors_1 = require(\"redis-errors\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst Command_1 = require(\"../Command\");\nconst ClusterAllFailedError_1 = require(\"../errors/ClusterAllFailedError\");\nconst Redis_1 = require(\"../Redis\");\nconst ScanStream_1 = require(\"../ScanStream\");\nconst transaction_1 = require(\"../transaction\");\nconst utils_1 = require(\"../utils\");\nconst applyMixin_1 = require(\"../utils/applyMixin\");\nconst Commander_1 = require(\"../utils/Commander\");\nconst ClusterOptions_1 = require(\"./ClusterOptions\");\nconst ClusterSubscriber_1 = require(\"./ClusterSubscriber\");\nconst ConnectionPool_1 = require(\"./ConnectionPool\");\nconst DelayQueue_1 = require(\"./DelayQueue\");\nconst util_1 = require(\"./util\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */\n        this._groupsIds = {};\n        /**\n         * @ignore\n         */\n        this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */\n        this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */\n        this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.redisOptions &&\n            this.options.redisOptions.keyPrefix &&\n            !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis) => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch((err) => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */\n    connect() {\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then((nodes) => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                const readyHandler = () => {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = () => {\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler();\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler();\n                    }\n                };\n                closeListener = () => {\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err) => {\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n            })\n                .catch((err) => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */\n    delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */\n    refreshSlotsCache(callback) {\n        if (this.isRefreshing) {\n            if (callback) {\n                process.nextTick(callback);\n            }\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error) => {\n            this.isRefreshing = false;\n            if (callback) {\n                callback(error);\n            }\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                ((0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this._groupsBySlot[slot] =\n                            _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    },\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    redis = _this.subscriber.getInstance();\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node,\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * @ignore\n     */\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), { timeout });\n            }\n            else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        }\n        else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain,\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(() => {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */\n    flushQueue(error) {\n        let item;\n        while ((item = this.offlineQueue.shift())) {\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while ((item = offlineQueue.shift())) {\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            const key = typeof nodeKey === \"string\"\n                ? nodeKey\n                : `${nodeKey.host}:${nodeKey.port}`;\n            const mapped = this.options.natMap[key];\n            if (mapped) {\n                debug(\"NAT mapping %s -> %O\", key, mapped);\n                return Object.assign({}, mapped);\n            }\n        }\n        return typeof nodeKey === \"string\"\n            ? (0, util_1.nodeKeyToRedisOptions)(nodeKey)\n            : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName),\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1],\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for (let i = 0; i < 16384; i++) {\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks) {\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */\n    readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res) => {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.resolveSrv(hostname, (err, records) => {\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host) => resolve({\n                        host,\n                        port: record.port,\n                    }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */\n    async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node) => {\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, { host: config });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports.default = Cluster;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}