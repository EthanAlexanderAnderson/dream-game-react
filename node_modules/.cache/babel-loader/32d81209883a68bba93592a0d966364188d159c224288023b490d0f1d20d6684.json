{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst cluster_1 = require(\"./cluster\");\nconst Command_1 = require(\"./Command\");\nconst connectors_1 = require(\"./connectors\");\nconst SentinelConnector_1 = require(\"./connectors/SentinelConnector\");\nconst eventHandler = require(\"./redis/event_handler\");\nconst RedisOptions_1 = require(\"./redis/RedisOptions\");\nconst ScanStream_1 = require(\"./ScanStream\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst applyMixin_1 = require(\"./utils/applyMixin\");\nconst Commander_1 = require(\"./utils/Commander\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n  constructor(arg1, arg2, arg3) {\n    super();\n    this.status = \"wait\";\n    /**\n     * @ignore\n     */\n    this.isCluster = false;\n    this.reconnectTimeout = null;\n    this.connectionEpoch = 0;\n    this.retryAttempts = 0;\n    this.manuallyClosing = false;\n    // Prepare autopipelines structures\n    this._autoPipelines = new Map();\n    this._runningAutoPipelines = new Set();\n    this.parseOptions(arg1, arg2, arg3);\n    events_1.EventEmitter.call(this);\n    this.resetCommandQueue();\n    this.resetOfflineQueue();\n    if (this.options.Connector) {\n      this.connector = new this.options.Connector(this.options);\n    } else if (this.options.sentinels) {\n      const sentinelConnector = new SentinelConnector_1.default(this.options);\n      sentinelConnector.emitter = this;\n      this.connector = sentinelConnector;\n    } else {\n      this.connector = new connectors_1.StandaloneConnector(this.options);\n    }\n    if (this.options.scripts) {\n      Object.entries(this.options.scripts).forEach(_ref => {\n        let [name, definition] = _ref;\n        this.defineCommand(name, definition);\n      });\n    }\n    // end(or wait) -> connecting -> connect -> ready -> end\n    if (this.options.lazyConnect) {\n      this.setStatus(\"wait\");\n    } else {\n      this.connect().catch(lodash_1.noop);\n    }\n  }\n  /**\n   * Create a Redis instance.\n   * This is the same as `new Redis()` but is included for compatibility with node-redis.\n   */\n  static createClient() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return new Redis(...args);\n  }\n  get autoPipelineQueueSize() {\n    let queued = 0;\n    for (const pipeline of this._autoPipelines.values()) {\n      queued += pipeline.length;\n    }\n    return queued;\n  }\n  /**\n   * Create a connection to Redis.\n   * This method will be invoked automatically when creating a new Redis instance\n   * unless `lazyConnect: true` is passed.\n   *\n   * When calling this method manually, a Promise is returned, which will\n   * be resolved when the connection status is ready.\n   */\n  connect(callback) {\n    const promise = new Promise((resolve, reject) => {\n      if (this.status === \"connecting\" || this.status === \"connect\" || this.status === \"ready\") {\n        reject(new Error(\"Redis is already connecting/connected\"));\n        return;\n      }\n      this.connectionEpoch += 1;\n      this.setStatus(\"connecting\");\n      const {\n        options\n      } = this;\n      this.condition = {\n        select: options.db,\n        auth: options.username ? [options.username, options.password] : options.password,\n        subscriber: false\n      };\n      const _this = this;\n      (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n        _this.silentEmit(type, err);\n      }), function (err, stream) {\n        if (err) {\n          _this.flushQueue(err);\n          _this.silentEmit(\"error\", err);\n          reject(err);\n          _this.setStatus(\"end\");\n          return;\n        }\n        let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n        if (\"sentinels\" in options && options.sentinels && !options.enableTLSForSentinelMode) {\n          CONNECT_EVENT = \"connect\";\n        }\n        _this.stream = stream;\n        if (options.noDelay) {\n          stream.setNoDelay(true);\n        }\n        // Node ignores setKeepAlive before connect, therefore we wait for the event:\n        // https://github.com/nodejs/node/issues/31663\n        if (typeof options.keepAlive === \"number\") {\n          if (stream.connecting) {\n            stream.once(CONNECT_EVENT, () => {\n              stream.setKeepAlive(true, options.keepAlive);\n            });\n          } else {\n            stream.setKeepAlive(true, options.keepAlive);\n          }\n        }\n        if (stream.connecting) {\n          stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n          if (options.connectTimeout) {\n            /*\n             * Typically, Socket#setTimeout(0) will clear the timer\n             * set before. However, in some platforms (Electron 3.x~4.x),\n             * the timer will not be cleared. So we introduce a variable here.\n             *\n             * See https://github.com/electron/electron/issues/14915\n             */\n            let connectTimeoutCleared = false;\n            stream.setTimeout(options.connectTimeout, function () {\n              if (connectTimeoutCleared) {\n                return;\n              }\n              stream.setTimeout(0);\n              stream.destroy();\n              const err = new Error(\"connect ETIMEDOUT\");\n              // @ts-expect-error\n              err.errorno = \"ETIMEDOUT\";\n              // @ts-expect-error\n              err.code = \"ETIMEDOUT\";\n              // @ts-expect-error\n              err.syscall = \"connect\";\n              eventHandler.errorHandler(_this)(err);\n            });\n            stream.once(CONNECT_EVENT, function () {\n              connectTimeoutCleared = true;\n              stream.setTimeout(0);\n            });\n          }\n        } else if (stream.destroyed) {\n          const firstError = _this.connector.firstError;\n          if (firstError) {\n            process.nextTick(() => {\n              eventHandler.errorHandler(_this)(firstError);\n            });\n          }\n          process.nextTick(eventHandler.closeHandler(_this));\n        } else {\n          process.nextTick(eventHandler.connectHandler(_this));\n        }\n        if (!stream.destroyed) {\n          stream.once(\"error\", eventHandler.errorHandler(_this));\n          stream.once(\"close\", eventHandler.closeHandler(_this));\n        }\n        const connectionReadyHandler = function () {\n          _this.removeListener(\"close\", connectionCloseHandler);\n          resolve();\n        };\n        var connectionCloseHandler = function () {\n          _this.removeListener(\"ready\", connectionReadyHandler);\n          reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n        };\n        _this.once(\"ready\", connectionReadyHandler);\n        _this.once(\"close\", connectionCloseHandler);\n      });\n    });\n    return (0, standard_as_callback_1.default)(promise, callback);\n  }\n  /**\n   * Disconnect from Redis.\n   *\n   * This method closes the connection immediately,\n   * and may lose some pending replies that haven't written to client.\n   * If you want to wait for the pending replies, use Redis#quit instead.\n   */\n  disconnect() {\n    let reconnect = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!reconnect) {\n      this.manuallyClosing = true;\n    }\n    if (this.reconnectTimeout && !reconnect) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n    if (this.status === \"wait\") {\n      eventHandler.closeHandler(this)();\n    } else {\n      this.connector.disconnect();\n    }\n  }\n  /**\n   * Disconnect from Redis.\n   *\n   * @deprecated\n   */\n  end() {\n    this.disconnect();\n  }\n  /**\n   * Create a new instance with the same options as the current one.\n   *\n   * @example\n   * ```js\n   * var redis = new Redis(6380);\n   * var anotherRedis = redis.duplicate();\n   * ```\n   */\n  duplicate(override) {\n    return new Redis({\n      ...this.options,\n      ...override\n    });\n  }\n  /**\n   * Mode of the connection.\n   *\n   * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n   * not in `\"normal\"` mode, certain commands are not allowed.\n   */\n  get mode() {\n    var _a;\n    return this.options.monitor ? \"monitor\" : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) ? \"subscriber\" : \"normal\";\n  }\n  /**\n   * Listen for all requests received by the server in real time.\n   *\n   * This command will create a new connection to Redis and send a\n   * MONITOR command via the new connection in order to avoid disturbing\n   * the current connection.\n   *\n   * @param callback The callback function. If omit, a promise will be returned.\n   * @example\n   * ```js\n   * var redis = new Redis();\n   * redis.monitor(function (err, monitor) {\n   *   // Entering monitoring mode.\n   *   monitor.on('monitor', function (time, args, source, database) {\n   *     console.log(time + \": \" + util.inspect(args));\n   *   });\n   * });\n   *\n   * // supports promise as well as other commands\n   * redis.monitor().then(function (monitor) {\n   *   monitor.on('monitor', function (time, args, source, database) {\n   *     console.log(time + \": \" + util.inspect(args));\n   *   });\n   * });\n   * ```\n   */\n  monitor(callback) {\n    const monitorInstance = this.duplicate({\n      monitor: true,\n      lazyConnect: false\n    });\n    return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n      monitorInstance.once(\"error\", reject);\n      monitorInstance.once(\"monitoring\", function () {\n        resolve(monitorInstance);\n      });\n    }), callback);\n  }\n  /**\n   * Send a command to Redis\n   *\n   * This method is used internally and in most cases you should not\n   * use it directly. If you need to send a command that is not supported\n   * by the library, you can use the `call` method:\n   *\n   * ```js\n   * const redis = new Redis();\n   *\n   * redis.call('set', 'foo', 'bar');\n   * // or\n   * redis.call(['set', 'foo', 'bar']);\n   * ```\n   *\n   * @ignore\n   */\n  sendCommand(command, stream) {\n    var _a, _b;\n    if (this.status === \"wait\") {\n      this.connect().catch(lodash_1.noop);\n    }\n    if (this.status === \"end\") {\n      command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n      return command.promise;\n    }\n    if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) && !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n      command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n      return command.promise;\n    }\n    if (typeof this.options.commandTimeout === \"number\") {\n      command.setTimeout(this.options.commandTimeout);\n    }\n    let writable = this.status === \"ready\" || !stream && this.status === \"connect\" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"loading\");\n    if (!this.stream) {\n      writable = false;\n    } else if (!this.stream.writable) {\n      writable = false;\n      // @ts-expect-error\n    } else if (this.stream._writableState && this.stream._writableState.ended) {\n      // TODO: We should be able to remove this as the PR has already been merged.\n      // https://github.com/iojs/io.js/pull/1217\n      writable = false;\n    }\n    if (!writable) {\n      if (!this.options.enableOfflineQueue) {\n        command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n        return command.promise;\n      }\n      if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n        this.disconnect();\n        command.resolve(Buffer.from(\"OK\"));\n        return command.promise;\n      }\n      // @ts-expect-error\n      if (debug.enabled) {\n        debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n      }\n      this.offlineQueue.push({\n        command: command,\n        stream: stream,\n        select: this.condition.select\n      });\n    } else {\n      // @ts-expect-error\n      if (debug.enabled) {\n        debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n      }\n      if (stream) {\n        if (\"isPipeline\" in stream && stream.isPipeline) {\n          stream.write(command.toWritable(stream.destination.redis.stream));\n        } else {\n          stream.write(command.toWritable(stream));\n        }\n      } else {\n        this.stream.write(command.toWritable(this.stream));\n      }\n      this.commandQueue.push({\n        command: command,\n        stream: stream,\n        select: this.condition.select\n      });\n      if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n        this.manuallyClosing = true;\n      }\n    }\n    if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n      const db = parseInt(command.args[0], 10);\n      if (this.condition.select !== db) {\n        this.condition.select = db;\n        this.emit(\"select\", db);\n        debug(\"switch to db [%d]\", this.condition.select);\n      }\n    }\n    return command.promise;\n  }\n  scanStream(options) {\n    return this.createScanStream(\"scan\", {\n      options\n    });\n  }\n  scanBufferStream(options) {\n    return this.createScanStream(\"scanBuffer\", {\n      options\n    });\n  }\n  sscanStream(key, options) {\n    return this.createScanStream(\"sscan\", {\n      key,\n      options\n    });\n  }\n  sscanBufferStream(key, options) {\n    return this.createScanStream(\"sscanBuffer\", {\n      key,\n      options\n    });\n  }\n  hscanStream(key, options) {\n    return this.createScanStream(\"hscan\", {\n      key,\n      options\n    });\n  }\n  hscanBufferStream(key, options) {\n    return this.createScanStream(\"hscanBuffer\", {\n      key,\n      options\n    });\n  }\n  zscanStream(key, options) {\n    return this.createScanStream(\"zscan\", {\n      key,\n      options\n    });\n  }\n  zscanBufferStream(key, options) {\n    return this.createScanStream(\"zscanBuffer\", {\n      key,\n      options\n    });\n  }\n  /**\n   * Emit only when there's at least one listener.\n   *\n   * @ignore\n   */\n  silentEmit(eventName, arg) {\n    let error;\n    if (eventName === \"error\") {\n      error = arg;\n      if (this.status === \"end\") {\n        return;\n      }\n      if (this.manuallyClosing) {\n        // ignore connection related errors when manually disconnecting\n        if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n        // @ts-expect-error\n        error.syscall === \"connect\" ||\n        // @ts-expect-error\n        error.syscall === \"read\")) {\n          return;\n        }\n      }\n    }\n    if (this.listeners(eventName).length > 0) {\n      return this.emit.apply(this, arguments);\n    }\n    if (error && error instanceof Error) {\n      console.error(\"[ioredis] Unhandled error event:\", error.stack);\n    }\n    return false;\n  }\n  /**\n   * @ignore\n   */\n  recoverFromFatalError(_commandError, err, options) {\n    this.flushQueue(err, options);\n    this.silentEmit(\"error\", err);\n    this.disconnect(true);\n  }\n  /**\n   * @ignore\n   */\n  handleReconnection(err, item) {\n    var _a;\n    let needReconnect = false;\n    if (this.options.reconnectOnError) {\n      needReconnect = this.options.reconnectOnError(err);\n    }\n    switch (needReconnect) {\n      case 1:\n      case true:\n        if (this.status !== \"reconnecting\") {\n          this.disconnect(true);\n        }\n        item.command.reject(err);\n        break;\n      case 2:\n        if (this.status !== \"reconnecting\") {\n          this.disconnect(true);\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select && item.command.name !== \"select\") {\n          this.select(item.select);\n        }\n        // TODO\n        // @ts-expect-error\n        this.sendCommand(item.command);\n        break;\n      default:\n        item.command.reject(err);\n    }\n  }\n  /**\n   * Get description of the connection. Used for debugging.\n   */\n  _getDescription() {\n    let description;\n    if (\"path\" in this.options && this.options.path) {\n      description = this.options.path;\n    } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {\n      description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n    } else if (\"host\" in this.options && this.options.host) {\n      description = this.options.host + \":\" + this.options.port;\n    } else {\n      // Unexpected\n      description = \"\";\n    }\n    if (this.options.connectionName) {\n      description += ` (${this.options.connectionName})`;\n    }\n    return description;\n  }\n  resetCommandQueue() {\n    this.commandQueue = new Deque();\n  }\n  resetOfflineQueue() {\n    this.offlineQueue = new Deque();\n  }\n  parseOptions() {\n    const options = {};\n    let isTls = false;\n    for (let i = 0; i < arguments.length; ++i) {\n      const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n      if (arg === null || typeof arg === \"undefined\") {\n        continue;\n      }\n      if (typeof arg === \"object\") {\n        (0, lodash_1.defaults)(options, arg);\n      } else if (typeof arg === \"string\") {\n        (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n        if (arg.startsWith(\"rediss://\")) {\n          isTls = true;\n        }\n      } else if (typeof arg === \"number\") {\n        options.port = arg;\n      } else {\n        throw new Error(\"Invalid argument \" + arg);\n      }\n    }\n    if (isTls) {\n      (0, lodash_1.defaults)(options, {\n        tls: true\n      });\n    }\n    (0, lodash_1.defaults)(options, Redis.defaultOptions);\n    if (typeof options.port === \"string\") {\n      options.port = parseInt(options.port, 10);\n    }\n    if (typeof options.db === \"string\") {\n      options.db = parseInt(options.db, 10);\n    }\n    // @ts-expect-error\n    this.options = (0, utils_1.resolveTLSProfile)(options);\n  }\n  /**\n   * Change instance's status\n   */\n  setStatus(status, arg) {\n    // @ts-expect-error\n    if (debug.enabled) {\n      debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n    }\n    this.status = status;\n    process.nextTick(this.emit.bind(this, status, arg));\n  }\n  createScanStream(command, _ref2) {\n    let {\n      key,\n      options = {}\n    } = _ref2;\n    return new ScanStream_1.default({\n      objectMode: true,\n      key: key,\n      redis: this,\n      command: command,\n      ...options\n    });\n  }\n  /**\n   * Flush offline queue and command queue with error.\n   *\n   * @param error The error object to send to the commands\n   * @param options options\n   */\n  flushQueue(error, options) {\n    options = (0, lodash_1.defaults)({}, options, {\n      offlineQueue: true,\n      commandQueue: true\n    });\n    let item;\n    if (options.offlineQueue) {\n      while (item = this.offlineQueue.shift()) {\n        item.command.reject(error);\n      }\n    }\n    if (options.commandQueue) {\n      if (this.commandQueue.length > 0) {\n        if (this.stream) {\n          this.stream.removeAllListeners(\"data\");\n        }\n        while (item = this.commandQueue.shift()) {\n          item.command.reject(error);\n        }\n      }\n    }\n  }\n  /**\n   * Check whether Redis has finished loading the persistent data and is able to\n   * process commands.\n   */\n  _readyCheck(callback) {\n    const _this = this;\n    this.info(function (err, res) {\n      if (err) {\n        if (err.message && err.message.includes(\"NOPERM\")) {\n          console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n          return callback(null, {});\n        }\n        return callback(err);\n      }\n      if (typeof res !== \"string\") {\n        return callback(null, res);\n      }\n      const info = {};\n      const lines = res.split(\"\\r\\n\");\n      for (let i = 0; i < lines.length; ++i) {\n        const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n        const fieldValue = fieldValueParts.join(\":\");\n        if (fieldValue) {\n          info[fieldName] = fieldValue;\n        }\n      }\n      if (!info.loading || info.loading === \"0\") {\n        callback(null, info);\n      } else {\n        const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n        const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;\n        debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n        setTimeout(function () {\n          _this._readyCheck(callback);\n        }, retryTime);\n      }\n    }).catch(lodash_1.noop);\n  }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports.default = Redis;","map":{"version":3,"names":["Object","defineProperty","exports","value","commands_1","require","events_1","standard_as_callback_1","cluster_1","Command_1","connectors_1","SentinelConnector_1","eventHandler","RedisOptions_1","ScanStream_1","transaction_1","utils_1","applyMixin_1","Commander_1","lodash_1","Deque","debug","Debug","Redis","default","constructor","arg1","arg2","arg3","status","isCluster","reconnectTimeout","connectionEpoch","retryAttempts","manuallyClosing","_autoPipelines","Map","_runningAutoPipelines","Set","parseOptions","EventEmitter","call","resetCommandQueue","resetOfflineQueue","options","Connector","connector","sentinels","sentinelConnector","emitter","StandaloneConnector","scripts","entries","forEach","_ref","name","definition","defineCommand","lazyConnect","setStatus","connect","catch","noop","createClient","_len","arguments","length","args","Array","_key","autoPipelineQueueSize","queued","pipeline","values","callback","promise","Promise","resolve","reject","Error","condition","select","db","auth","username","password","subscriber","_this","type","err","silentEmit","stream","flushQueue","CONNECT_EVENT","tls","enableTLSForSentinelMode","noDelay","setNoDelay","keepAlive","connecting","once","setKeepAlive","connectHandler","connectTimeout","connectTimeoutCleared","setTimeout","destroy","errorno","code","syscall","errorHandler","destroyed","firstError","process","nextTick","closeHandler","connectionReadyHandler","removeListener","connectionCloseHandler","CONNECTION_CLOSED_ERROR_MSG","disconnect","reconnect","undefined","clearTimeout","end","duplicate","override","mode","_a","monitor","monitorInstance","sendCommand","command","_b","checkFlag","commandTimeout","writable","exists","hasFlag","_writableState","ended","enableOfflineQueue","offlineQueue","Buffer","from","enabled","_getDescription","push","isPipeline","write","toWritable","destination","redis","commandQueue","isInt","parseInt","emit","scanStream","createScanStream","scanBufferStream","sscanStream","key","sscanBufferStream","hscanStream","hscanBufferStream","zscanStream","zscanBufferStream","eventName","arg","error","message","listeners","apply","console","stack","recoverFromFatalError","_commandError","handleReconnection","item","needReconnect","reconnectOnError","description","path","remoteAddress","remotePort","host","port","connectionName","isTls","i","defaults","parseURL","startsWith","defaultOptions","resolveTLSProfile","bind","_ref2","objectMode","shift","removeAllListeners","_readyCheck","info","res","includes","warn","lines","split","fieldName","fieldValueParts","fieldValue","join","loading","loadingEtaMs","loading_eta_seconds","retryTime","maxLoadingRetryTime","Cluster","Command","DEFAULT_REDIS_OPTIONS","addTransactionSupport","prototype"],"sources":["C:/Users/Ethan/Desktop/Dream Game Site/v4/client/node_modules/ioredis/built/Redis.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commands_1 = require(\"@ioredis/commands\");\nconst events_1 = require(\"events\");\nconst standard_as_callback_1 = require(\"standard-as-callback\");\nconst cluster_1 = require(\"./cluster\");\nconst Command_1 = require(\"./Command\");\nconst connectors_1 = require(\"./connectors\");\nconst SentinelConnector_1 = require(\"./connectors/SentinelConnector\");\nconst eventHandler = require(\"./redis/event_handler\");\nconst RedisOptions_1 = require(\"./redis/RedisOptions\");\nconst ScanStream_1 = require(\"./ScanStream\");\nconst transaction_1 = require(\"./transaction\");\nconst utils_1 = require(\"./utils\");\nconst applyMixin_1 = require(\"./utils/applyMixin\");\nconst Commander_1 = require(\"./utils/Commander\");\nconst lodash_1 = require(\"./utils/lodash\");\nconst Deque = require(\"denque\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */\n        this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        }\n        else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        }\n        else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */\n    static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready.\n     */\n    connect(callback) {\n        const promise = new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username\n                    ? [options.username, options.password]\n                    : options.password,\n                subscriber: false,\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n                _this.silentEmit(type, err);\n            }), function (err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options &&\n                    options.sentinels &&\n                    !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, () => {\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    }\n                    else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */\n                        let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function () {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function () {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                }\n                else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(() => {\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                }\n                else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function () {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function () {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */\n    disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        }\n        else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */\n    end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */\n    duplicate(override) {\n        return new Redis({ ...this.options, ...override });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */\n    get mode() {\n        var _a;\n        return this.options.monitor\n            ? \"monitor\"\n            : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber)\n                ? \"subscriber\"\n                : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */\n    monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false,\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function () {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */\n    sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) &&\n            !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        let writable = this.status === \"ready\" ||\n            (!stream &&\n                this.status === \"connect\" &&\n                (0, commands_1.exists)(command.name) &&\n                (0, commands_1.hasFlag)(command.name, \"loading\"));\n        if (!this.stream) {\n            writable = false;\n        }\n        else if (!this.stream.writable) {\n            writable = false;\n            // @ts-expect-error\n        }\n        else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n        }\n        else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                }\n                else {\n                    stream.write(command.toWritable(stream));\n                }\n            }\n            else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", { options });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", { options });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */\n    silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error &&\n                    (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n                        // @ts-expect-error\n                        error.syscall === \"connect\" ||\n                        // @ts-expect-error\n                        error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */\n    recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */\n    handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch (needReconnect) {\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select &&\n                    item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */\n    _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        }\n        else if (this.stream &&\n            this.stream.remoteAddress &&\n            this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        }\n        else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        }\n        else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for (let i = 0; i < args.length; ++i) {\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            }\n            else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            }\n            else if (typeof arg === \"number\") {\n                options.port = arg;\n            }\n            else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, { tls: true });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */\n    setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */\n    flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true,\n        });\n        let item;\n        if (options.offlineQueue) {\n            while ((item = this.offlineQueue.shift())) {\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while ((item = this.commandQueue.shift())) {\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */\n    _readyCheck(callback) {\n        const _this = this;\n        this.info(function (err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            }\n            else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime &&\n                    _this.options.maxLoadingRetryTime < loadingEtaMs\n                    ? _this.options.maxLoadingRetryTime\n                    : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function () {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports.default = Redis;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}